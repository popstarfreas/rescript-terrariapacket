// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

let Stdlib_Option = require("@rescript/runtime/lib/js/Stdlib_Option.js");
let ArrayExt$TerrariaPacket = require("./ArrayExt.js");
let BitFlags$TerrariaPacket = require("./BitFlags.js");
let ErrorAwarePacketWriter$TerrariaPacket = require("./ErrorAwarePacketWriter.js");

function toString(self) {
  return `PerPlayerSliderPower { playerId: ` + self.playerId.toString() + `, value: ` + self.value.toString() + ` }`;
}

function pack(writer, self) {
  return ErrorAwarePacketWriter$TerrariaPacket.packSingle(ErrorAwarePacketWriter$TerrariaPacket.packByte(writer, self.playerId, "playerId"), self.value, "value");
}

function parse(reader) {
  return {
    playerId: reader.readByte(),
    value: reader.readSingle()
  };
}

function toString$1(self) {
  if (self.TAG === "Everyone") {
    return `Everyone { values: ` + self._0.map(value => {
      if (value) {
        return "1";
      } else {
        return "0";
      }
    }).join(", ") + ` }`;
  } else {
    return `Player { playerId: ` + self._0.toString() + `, value: ` + (
      self._1 ? "true" : "false"
    ) + ` }`;
  }
}

function pack$1(writer, self) {
  if (self.TAG === "Everyone") {
    let values = self._0;
    let bytes = ArrayExt$TerrariaPacket.intoChunks(values, 8).map(BitFlags$TerrariaPacket.fromArray).map(BitFlags$TerrariaPacket.toByte);
    return ErrorAwarePacketWriter$TerrariaPacket.packBytes(ErrorAwarePacketWriter$TerrariaPacket.packByte(writer, 0, "everyoneType"), bytes, "everyoneValues");
  } else {
    let playerId = self._0;
    let value = self._1;
    return ErrorAwarePacketWriter$TerrariaPacket.packByte(ErrorAwarePacketWriter$TerrariaPacket.packByte(ErrorAwarePacketWriter$TerrariaPacket.packByte(writer, 1, "playerType"), playerId, "playerId"), value ? 1 : 0, "playerValue");
  }
}

function parse$1(reader) {
  let match = reader.readByte();
  if (match !== 0) {
    if (match !== 1) {
      return;
    } else {
      return {
        TAG: "Player",
        _0: reader.readByte(),
        _1: reader.readByte() === 1
      };
    }
  } else {
    let toggles = [];
    for (let _for = 1; _for <= 32; ++_for) {
      let byte = reader.readByte();
      BitFlags$TerrariaPacket.forEach(BitFlags$TerrariaPacket.fromByte(byte), flag => {
        toggles.push(flag);
      });
    }
    toggles.pop();
    return {
      TAG: "Everyone",
      _0: toggles
    };
  }
}

function toString$2(self) {
  if (typeof self !== "object") {
    switch (self) {
      case "StartDayImmediately" :
        return `StartDayImmediately`;
      case "StartNoonImmediately" :
        return `StartNoonImmediately`;
      case "StartNightImmediately" :
        return `StartNightImmediately`;
      case "StartMidnightImmediately" :
        return `StartMidnightImmediately`;
    }
  } else {
    switch (self.TAG) {
      case "FreezeTime" :
        return `FreezeTime { value: ` + (
          self._0 ? "true" : "false"
        ) + ` }`;
      case "GodmodePower" :
        return `GodmodePower { message: ` + toString$1(self._0) + ` }`;
      case "ModifyWindDirectionAndStrength" :
        return `ModifyWindDirectionAndStrength { value: ` + self._0.toString() + ` }`;
      case "ModifyRainPower" :
        return `ModifyRainPower { value: ` + self._0.toString() + ` }`;
      case "ModifyTimeRate" :
        return `ModifyTimeRate { value: ` + self._0.toString() + ` }`;
      case "FreezeRainPower" :
        return `FreezeRainPower { value: ` + (
          self._0 ? "true" : "false"
        ) + ` }`;
      case "FreezeWindDirectionAndStrength" :
        return `FreezeWindDirectionAndStrength { value: ` + (
          self._0 ? "true" : "false"
        ) + ` }`;
      case "FarPlacementRangePower" :
        return `FarPlacementRangePower { message: ` + toString$1(self._0) + ` }`;
      case "DifficultySliderPower" :
        return `DifficultySliderPower { value: ` + self._0.toString() + ` }`;
      case "StopBiomeSpreadPower" :
        return `StopBiomeSpreadPower { value: ` + (
          self._0 ? "true" : "false"
        ) + ` }`;
      case "SpawnRateSliderPerPlayerPower" :
        return `SpawnRateSliderPerPlayerPower { sliderPower: ` + toString(self._0) + ` }`;
    }
  }
}

function toString$3(self) {
  switch (self) {
    case "FreezeTime" :
      return "FreezeTime";
    case "StartDayImmediately" :
      return "StartDayImmediately";
    case "StartNoonImmediately" :
      return "StartNoonImmediately";
    case "StartNightImmediately" :
      return "StartNightImmediately";
    case "StartMidnightImmediately" :
      return "StartMidnightImmediately";
    case "GodmodePower" :
      return "GodmodePower";
    case "ModifyWindDirectionAndStrength" :
      return "ModifyWindDirectionAndStrength";
    case "ModifyRainPower" :
      return "ModifyRainPower";
    case "ModifyTimeRate" :
      return "ModifyTimeRate";
    case "FreezeRainPower" :
      return "FreezeRainPower";
    case "FreezeWindDirectionAndStrength" :
      return "FreezeWindDirectionAndStrength";
    case "FarPlacementRangePower" :
      return "FarPlacementRangePower";
    case "DifficultySliderPower" :
      return "DifficultySliderPower";
    case "StopBiomeSpreadPower" :
      return "StopBiomeSpreadPower";
    case "SpawnRateSliderPerPlayerPower" :
      return "SpawnRateSliderPerPlayerPower";
  }
}

function fromInt(n) {
  switch (n) {
    case 0 :
      return "FreezeTime";
    case 1 :
      return "StartDayImmediately";
    case 2 :
      return "StartNoonImmediately";
    case 3 :
      return "StartNightImmediately";
    case 4 :
      return "StartMidnightImmediately";
    case 5 :
      return "GodmodePower";
    case 6 :
      return "ModifyWindDirectionAndStrength";
    case 7 :
      return "ModifyRainPower";
    case 8 :
      return "ModifyTimeRate";
    case 9 :
      return "FreezeRainPower";
    case 10 :
      return "FreezeWindDirectionAndStrength";
    case 11 :
      return "FarPlacementRangePower";
    case 12 :
      return "DifficultySliderPower";
    case 13 :
      return "StopBiomeSpreadPower";
    case 14 :
      return "SpawnRateSliderPerPlayerPower";
    default:
      return;
  }
}

function toInt(self) {
  switch (self) {
    case "FreezeTime" :
      return 0;
    case "StartDayImmediately" :
      return 1;
    case "StartNoonImmediately" :
      return 2;
    case "StartNightImmediately" :
      return 3;
    case "StartMidnightImmediately" :
      return 4;
    case "GodmodePower" :
      return 5;
    case "ModifyWindDirectionAndStrength" :
      return 6;
    case "ModifyRainPower" :
      return 7;
    case "ModifyTimeRate" :
      return 8;
    case "FreezeRainPower" :
      return 9;
    case "FreezeWindDirectionAndStrength" :
      return 10;
    case "FarPlacementRangePower" :
      return 11;
    case "DifficultySliderPower" :
      return 12;
    case "StopBiomeSpreadPower" :
      return 13;
    case "SpawnRateSliderPerPlayerPower" :
      return 14;
  }
}

let CreativePowerType = {
  toString: toString$3,
  fromInt: fromInt,
  toInt: toInt
};

function pack$2(writer, self) {
  if (typeof self !== "object") {
    switch (self) {
      case "StartDayImmediately" :
        return ErrorAwarePacketWriter$TerrariaPacket.packUInt16(writer, 1, "startDayImmediatelyType");
      case "StartNoonImmediately" :
        return ErrorAwarePacketWriter$TerrariaPacket.packUInt16(writer, 2, "startNoonImmediatelyType");
      case "StartNightImmediately" :
        return ErrorAwarePacketWriter$TerrariaPacket.packUInt16(writer, 3, "startNightImmediatelyType");
      case "StartMidnightImmediately" :
        return ErrorAwarePacketWriter$TerrariaPacket.packUInt16(writer, 4, "startMidnightImmediatelyType");
    }
  } else {
    switch (self.TAG) {
      case "FreezeTime" :
        let value = self._0;
        return ErrorAwarePacketWriter$TerrariaPacket.packByte(ErrorAwarePacketWriter$TerrariaPacket.packUInt16(writer, 0, "freezeTimeType"), value ? 1 : 0, "freezeTimeValue");
      case "GodmodePower" :
        let message = self._0;
        return pack$1(ErrorAwarePacketWriter$TerrariaPacket.packUInt16(writer, 5, "godmodePowerType"), message);
      case "ModifyWindDirectionAndStrength" :
        let value$1 = self._0;
        return ErrorAwarePacketWriter$TerrariaPacket.packSingle(ErrorAwarePacketWriter$TerrariaPacket.packUInt16(writer, 6, "modifyWindDirectionAndStrengthType"), value$1, "modifyWindDirectionAndStrengthValue");
      case "ModifyRainPower" :
        let value$2 = self._0;
        return ErrorAwarePacketWriter$TerrariaPacket.packSingle(ErrorAwarePacketWriter$TerrariaPacket.packUInt16(writer, 7, "modifyRainPowerType"), value$2, "modifyRainPowerValue");
      case "ModifyTimeRate" :
        let value$3 = self._0;
        return ErrorAwarePacketWriter$TerrariaPacket.packSingle(ErrorAwarePacketWriter$TerrariaPacket.packUInt16(writer, 8, "modifyTimeRateType"), value$3, "modifyTimeRateValue");
      case "FreezeRainPower" :
        let on = self._0;
        return ErrorAwarePacketWriter$TerrariaPacket.packByte(ErrorAwarePacketWriter$TerrariaPacket.packUInt16(writer, 9, "freezeRainPowerType"), on ? 1 : 0, "freezeRainPowerValue");
      case "FreezeWindDirectionAndStrength" :
        let on$1 = self._0;
        return ErrorAwarePacketWriter$TerrariaPacket.packByte(ErrorAwarePacketWriter$TerrariaPacket.packUInt16(writer, 10, "freezeWindDirectionAndStrengthType"), on$1 ? 1 : 0, "freezeWindDirectionAndStrengthValue");
      case "FarPlacementRangePower" :
        let message$1 = self._0;
        return pack$1(ErrorAwarePacketWriter$TerrariaPacket.packUInt16(writer, 11, "farPlacementRangePowerType"), message$1);
      case "DifficultySliderPower" :
        let value$4 = self._0;
        return ErrorAwarePacketWriter$TerrariaPacket.packSingle(ErrorAwarePacketWriter$TerrariaPacket.packUInt16(writer, 12, "difficultySliderPowerType"), value$4, "difficultySliderPowerValue");
      case "StopBiomeSpreadPower" :
        let on$2 = self._0;
        return ErrorAwarePacketWriter$TerrariaPacket.packByte(ErrorAwarePacketWriter$TerrariaPacket.packUInt16(writer, 13, "stopBiomeSpreadPowerType"), on$2 ? 1 : 0, "stopBiomeSpreadPowerValue");
      case "SpawnRateSliderPerPlayerPower" :
        let message$2 = self._0;
        return pack(ErrorAwarePacketWriter$TerrariaPacket.packUInt16(writer, 14, "spawnRateSliderPerPlayerPowerType"), message$2);
    }
  }
}

function parse$2(reader) {
  let match = reader.readUInt16();
  switch (match) {
    case 0 :
      return {
        TAG: "FreezeTime",
        _0: reader.readByte() === 1
      };
    case 1 :
      return "StartDayImmediately";
    case 2 :
      return "StartNoonImmediately";
    case 3 :
      return "StartNightImmediately";
    case 4 :
      return "StartMidnightImmediately";
    case 5 :
      return Stdlib_Option.map(parse$1(reader), m => ({
        TAG: "GodmodePower",
        _0: m
      }));
    case 6 :
      return {
        TAG: "ModifyWindDirectionAndStrength",
        _0: reader.readSingle()
      };
    case 7 :
      return {
        TAG: "ModifyRainPower",
        _0: reader.readSingle()
      };
    case 8 :
      return {
        TAG: "ModifyTimeRate",
        _0: reader.readSingle()
      };
    case 9 :
      return {
        TAG: "FreezeRainPower",
        _0: reader.readByte() === 1
      };
    case 10 :
      return {
        TAG: "FreezeWindDirectionAndStrength",
        _0: reader.readByte() === 1
      };
    case 11 :
      return Stdlib_Option.map(parse$1(reader), m => ({
        TAG: "FarPlacementRangePower",
        _0: m
      }));
    case 12 :
      return {
        TAG: "DifficultySliderPower",
        _0: reader.readSingle()
      };
    case 13 :
      return {
        TAG: "StopBiomeSpreadPower",
        _0: reader.readByte() === 1
      };
    case 14 :
      return Stdlib_Option.map(parse(reader), m => ({
        TAG: "SpawnRateSliderPerPlayerPower",
        _0: m
      }));
    default:
      return;
  }
}

let PerPlayerSliderPower = {
  pack: pack,
  parse: parse
};

let PerPlayerTogglePower = {
  pack: pack$1,
  parse: parse$1
};

exports.PerPlayerSliderPower = PerPlayerSliderPower;
exports.PerPlayerTogglePower = PerPlayerTogglePower;
exports.toString = toString$2;
exports.CreativePowerType = CreativePowerType;
exports.pack = pack$2;
exports.parse = parse$2;
/* ErrorAwarePacketWriter-TerrariaPacket Not a pure module */
