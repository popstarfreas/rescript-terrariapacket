// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

let Nodezlib = require("node:zlib");
let Belt_Array = require("@rescript/runtime/lib/js/Belt_Array.js");
let Belt_Option = require("@rescript/runtime/lib/js/Belt_Option.js");
let Stdlib_Result = require("@rescript/runtime/lib/js/Stdlib_Result.js");
let Primitive_object = require("@rescript/runtime/lib/js/Primitive_object.js");
let Primitive_exceptions = require("@rescript/runtime/lib/js/Primitive_exceptions.js");
let BitFlags$TerrariaPacket = require("../BitFlags.js");
let TileSolid$TerrariaPacket = require("../TileSolid.js");
let PacketType$TerrariaPacket = require("../PacketType.js");
let TileFrameImportant$TerrariaPacket = require("../TileFrameImportant.js");
let ErrorAwareBufferReader$TerrariaPacket = require("../ErrorAwareBufferReader.js");
let ErrorAwareBufferWriter$TerrariaPacket = require("../ErrorAwareBufferWriter.js");
let ErrorAwarePacketReader$TerrariaPacket = require("../ErrorAwarePacketReader.js");
let ErrorAwarePacketWriter$TerrariaPacket = require("../ErrorAwarePacketWriter.js");
let Bufferreader = require("@popstarfreas/packetfactory/bufferreader").default;
let Packetreader = require("@popstarfreas/packetfactory/packetreader").default;

function defaultTileCache() {
  return {
    activeTile: undefined,
    color: undefined,
    wallColor: undefined,
    wall: undefined,
    liquid: undefined,
    lava: false,
    honey: false,
    wire: false,
    wire2: false,
    wire3: false,
    wire4: false,
    halfBrick: false,
    slope: undefined,
    actuator: false,
    inActive: false,
    coatHeader: 0
  };
}

function cacheToTile(cache) {
  return {
    activeTile: cache.activeTile,
    color: cache.color,
    wallColor: cache.wallColor,
    wall: cache.wall,
    liquid: cache.liquid,
    lava: cache.lava,
    honey: cache.honey,
    wire: cache.wire,
    wire2: cache.wire2,
    wire3: cache.wire3,
    wire4: cache.wire4,
    halfBrick: cache.halfBrick,
    slope: cache.slope,
    actuator: cache.actuator,
    inActive: cache.inActive,
    coatHeader: cache.coatHeader
  };
}

function parse(reader) {
  let e = ErrorAwareBufferReader$TerrariaPacket.readInt16(reader, "id");
  if (e.TAG !== "Ok") {
    return e;
  }
  let e$1 = ErrorAwareBufferReader$TerrariaPacket.readInt16(reader, "x");
  if (e$1.TAG !== "Ok") {
    return e$1;
  }
  let e$2 = ErrorAwareBufferReader$TerrariaPacket.readInt16(reader, "y");
  if (e$2.TAG !== "Ok") {
    return e$2;
  }
  let e$3 = ErrorAwareBufferReader$TerrariaPacket.readString(reader, "name");
  if (e$3.TAG === "Ok") {
    return {
      TAG: "Ok",
      _0: {
        id: e._0,
        x: e$1._0,
        y: e$2._0,
        name: e$3._0
      }
    };
  } else {
    return e$3;
  }
}

function pack(writer, chest) {
  return ErrorAwareBufferWriter$TerrariaPacket.packString(ErrorAwareBufferWriter$TerrariaPacket.packInt16(ErrorAwareBufferWriter$TerrariaPacket.packInt16(ErrorAwareBufferWriter$TerrariaPacket.packInt16(writer, chest.id, "id"), chest.x, "x"), chest.y, "y"), chest.name, "name");
}

let Chest = {
  readString: ErrorAwareBufferReader$TerrariaPacket.readString,
  readInt16: ErrorAwareBufferReader$TerrariaPacket.readInt16,
  parse: parse,
  packInt16: ErrorAwareBufferWriter$TerrariaPacket.packInt16,
  packString: ErrorAwareBufferWriter$TerrariaPacket.packString,
  pack: pack
};

function parse$1(reader) {
  let e = ErrorAwareBufferReader$TerrariaPacket.readInt16(reader, "id");
  if (e.TAG !== "Ok") {
    return e;
  }
  let e$1 = ErrorAwareBufferReader$TerrariaPacket.readInt16(reader, "x");
  if (e$1.TAG !== "Ok") {
    return e$1;
  }
  let e$2 = ErrorAwareBufferReader$TerrariaPacket.readInt16(reader, "y");
  if (e$2.TAG !== "Ok") {
    return e$2;
  }
  let e$3 = ErrorAwareBufferReader$TerrariaPacket.readString(reader, "name");
  if (e$3.TAG === "Ok") {
    return {
      TAG: "Ok",
      _0: {
        id: e._0,
        x: e$1._0,
        y: e$2._0,
        name: e$3._0
      }
    };
  } else {
    return e$3;
  }
}

function pack$1(writer, sign) {
  return ErrorAwareBufferWriter$TerrariaPacket.packString(ErrorAwareBufferWriter$TerrariaPacket.packInt16(ErrorAwareBufferWriter$TerrariaPacket.packInt16(ErrorAwareBufferWriter$TerrariaPacket.packInt16(writer, sign.id, "id"), sign.x, "x"), sign.y, "y"), sign.name, "name");
}

let Sign = {
  readString: ErrorAwareBufferReader$TerrariaPacket.readString,
  readInt16: ErrorAwareBufferReader$TerrariaPacket.readInt16,
  parse: parse$1,
  packInt16: ErrorAwareBufferWriter$TerrariaPacket.packInt16,
  packString: ErrorAwareBufferWriter$TerrariaPacket.packString,
  pack: pack$1
};

function parseTrainingDummyKind(reader) {
  let e = ErrorAwareBufferReader$TerrariaPacket.readInt16(reader, "npcSlotId");
  if (e.TAG === "Ok") {
    return {
      TAG: "Ok",
      _0: {
        npcSlotId: e._0
      }
    };
  } else {
    return e;
  }
}

function parseDisplayItem(reader) {
  let e = ErrorAwareBufferReader$TerrariaPacket.readInt16(reader, "netId");
  if (e.TAG !== "Ok") {
    return e;
  }
  let e$1 = ErrorAwareBufferReader$TerrariaPacket.readByte(reader, "prefix");
  if (e$1.TAG !== "Ok") {
    return e$1;
  }
  let e$2 = ErrorAwareBufferReader$TerrariaPacket.readInt16(reader, "stack");
  if (e$2.TAG === "Ok") {
    return {
      TAG: "Ok",
      _0: {
        netId: e._0,
        prefix: e$1._0,
        stack: e$2._0
      }
    };
  } else {
    return e$2;
  }
}

function parseLogicSensorKind(reader) {
  let e = ErrorAwareBufferReader$TerrariaPacket.readByte(reader, "checkType");
  if (e.TAG !== "Ok") {
    return e;
  }
  let e$1 = ErrorAwareBufferReader$TerrariaPacket.readByte(reader, "on");
  if (e$1.TAG === "Ok") {
    return {
      TAG: "Ok",
      _0: {
        checkType: e._0,
        on: e$1._0 === 1
      }
    };
  } else {
    return e$1;
  }
}

function parseDisplayDollKind(reader) {
  let e = ErrorAwareBufferReader$TerrariaPacket.readByte(reader, "itemsFlags");
  if (e.TAG !== "Ok") {
    return e;
  }
  let itemsFlags = BitFlags$TerrariaPacket.fromByte(e._0);
  let e$1 = ErrorAwareBufferReader$TerrariaPacket.readByte(reader, "dyeFlags");
  if (e$1.TAG !== "Ok") {
    return e$1;
  }
  let dyeFlags = BitFlags$TerrariaPacket.fromByte(e$1._0);
  let items = [];
  let dyes = [];
  let parseResult = {
    TAG: "Ok",
    _0: undefined
  };
  for (let i = 0; i <= 7; ++i) {
    let match = parseResult;
    if (match.TAG === "Ok") {
      if (BitFlags$TerrariaPacket.flagN(itemsFlags, i)) {
        let item = parseDisplayItem(reader);
        if (item.TAG === "Ok") {
          items.push(item._0);
        } else {
          parseResult = {
            TAG: "Error",
            _0: item._0
          };
        }
      } else {
        items.push(undefined);
      }
    }
  }
  for (let i$1 = 0; i$1 <= 7; ++i$1) {
    let match$1 = parseResult;
    if (match$1.TAG === "Ok") {
      if (BitFlags$TerrariaPacket.flagN(dyeFlags, i$1)) {
        let item$1 = parseDisplayItem(reader);
        if (item$1.TAG === "Ok") {
          dyes.push(item$1._0);
        } else {
          parseResult = {
            TAG: "Error",
            _0: item$1._0
          };
        }
      } else {
        dyes.push(undefined);
      }
    }
  }
  let err = parseResult;
  if (err.TAG === "Ok") {
    return {
      TAG: "Ok",
      _0: {
        items: items,
        dyes: dyes
      }
    };
  } else {
    return {
      TAG: "Error",
      _0: err._0
    };
  }
}

function parseHatRackKind(reader) {
  let e = ErrorAwareBufferReader$TerrariaPacket.readByte(reader, "flags");
  if (e.TAG !== "Ok") {
    return e;
  }
  let flags = BitFlags$TerrariaPacket.fromByte(e._0);
  let items = [];
  let dyes = [];
  let parseResult = {
    TAG: "Ok",
    _0: undefined
  };
  for (let i = 0; i <= 1; ++i) {
    let match = parseResult;
    if (match.TAG === "Ok") {
      if (BitFlags$TerrariaPacket.flagN(flags, i)) {
        let item = parseDisplayItem(reader);
        if (item.TAG === "Ok") {
          items.push(item._0);
        } else {
          parseResult = {
            TAG: "Error",
            _0: item._0
          };
        }
      } else {
        items.push(undefined);
      }
    }
  }
  for (let i$1 = 0; i$1 <= 1; ++i$1) {
    let match$1 = parseResult;
    if (match$1.TAG === "Ok") {
      if (BitFlags$TerrariaPacket.flagN(flags, i$1 + 2 | 0)) {
        let item$1 = parseDisplayItem(reader);
        if (item$1.TAG === "Ok") {
          dyes.push(item$1._0);
        } else {
          parseResult = {
            TAG: "Error",
            _0: item$1._0
          };
        }
      } else {
        dyes.push(undefined);
      }
    }
  }
  let err = parseResult;
  if (err.TAG === "Ok") {
    return {
      TAG: "Ok",
      _0: {
        items: items,
        dyes: dyes
      }
    };
  } else {
    return {
      TAG: "Error",
      _0: err._0
    };
  }
}

function parse$2(reader) {
  let e = ErrorAwareBufferReader$TerrariaPacket.readByte(reader, "entityType");
  if (e.TAG !== "Ok") {
    return e;
  }
  let entityType = e._0;
  let e$1 = ErrorAwareBufferReader$TerrariaPacket.readInt16(reader, "x");
  if (e$1.TAG !== "Ok") {
    return e$1;
  }
  let e$2 = ErrorAwareBufferReader$TerrariaPacket.readInt16(reader, "y");
  if (e$2.TAG !== "Ok") {
    return e$2;
  }
  let e$3;
  switch (entityType) {
    case 0 :
      e$3 = Stdlib_Result.map(parseTrainingDummyKind(reader), v => ({
        TAG: "TrainingDummy",
        _0: v
      }));
      break;
    case 1 :
      e$3 = Stdlib_Result.map(parseDisplayItem(reader), v => ({
        TAG: "ItemFrame",
        _0: v
      }));
      break;
    case 2 :
      e$3 = Stdlib_Result.map(parseLogicSensorKind(reader), v => ({
        TAG: "LogicSensor",
        _0: v
      }));
      break;
    case 3 :
      e$3 = Stdlib_Result.map(parseDisplayDollKind(reader), v => ({
        TAG: "DisplayDoll",
        _0: v
      }));
      break;
    case 4 :
      e$3 = Stdlib_Result.map(parseDisplayItem(reader), v => ({
        TAG: "WeaponsRack",
        _0: v
      }));
      break;
    case 5 :
      e$3 = Stdlib_Result.map(parseHatRackKind(reader), v => ({
        TAG: "HatRack",
        _0: v
      }));
      break;
    case 6 :
      e$3 = Stdlib_Result.map(parseDisplayItem(reader), v => ({
        TAG: "FoodPlatter",
        _0: v
      }));
      break;
    case 7 :
      e$3 = {
        TAG: "Ok",
        _0: {
          TAG: "TeleportationPylon",
          _0: undefined
        }
      };
      break;
    default:
      e$3 = {
        TAG: "Error",
        _0: {
          context: "Entity.parse",
          error: new Error("Unknown entity kind: " + String(entityType))
        }
      };
  }
  if (e$3.TAG === "Ok") {
    return {
      TAG: "Ok",
      _0: {
        entityType: entityType,
        x: e$1._0,
        y: e$2._0,
        entityKind: e$3._0
      }
    };
  } else {
    return e$3;
  }
}

function packTrainingDummy(writer, trainingDummy) {
  return ErrorAwareBufferWriter$TerrariaPacket.packInt16(writer, trainingDummy.npcSlotId, "npcSlotId");
}

function packDisplayItem(writer, displayItem) {
  return ErrorAwareBufferWriter$TerrariaPacket.packInt16(ErrorAwareBufferWriter$TerrariaPacket.packByte(ErrorAwareBufferWriter$TerrariaPacket.packInt16(writer, displayItem.netId, "netId"), displayItem.prefix, "prefix"), displayItem.stack, "stack");
}

function packLogicSensor(writer, logicSensorKind) {
  return ErrorAwareBufferWriter$TerrariaPacket.packByte(ErrorAwareBufferWriter$TerrariaPacket.packByte(writer, logicSensorKind.checkType, "checkType"), logicSensorKind.on ? 1 : 0, "on");
}

function hasItem(arr, n) {
  return Belt_Option.isSome(Belt_Option.flatMap(Belt_Array.get(arr, n), a => a));
}

function packDisplayDoll(writer, displayDollKind) {
  let itemFlags = BitFlags$TerrariaPacket.fromFlags(hasItem(displayDollKind.items, 0), hasItem(displayDollKind.items, 1), hasItem(displayDollKind.items, 2), hasItem(displayDollKind.items, 3), hasItem(displayDollKind.items, 4), hasItem(displayDollKind.items, 5), hasItem(displayDollKind.items, 6), hasItem(displayDollKind.items, 7));
  let dyeFlags = BitFlags$TerrariaPacket.fromFlags(hasItem(displayDollKind.dyes, 0), hasItem(displayDollKind.dyes, 1), hasItem(displayDollKind.dyes, 2), hasItem(displayDollKind.dyes, 3), hasItem(displayDollKind.dyes, 4), hasItem(displayDollKind.dyes, 5), hasItem(displayDollKind.dyes, 6), hasItem(displayDollKind.dyes, 7));
  ErrorAwareBufferWriter$TerrariaPacket.packByte(ErrorAwareBufferWriter$TerrariaPacket.packByte(writer, BitFlags$TerrariaPacket.toByte(itemFlags), "itemFlags"), BitFlags$TerrariaPacket.toByte(dyeFlags), "dyeFlags");
  for (let i = 0; i <= 7; ++i) {
    let item = Belt_Option.flatMap(Belt_Array.get(displayDollKind.items, i), a => a);
    if (item !== undefined) {
      packDisplayItem(writer, item);
    }
  }
  for (let i$1 = 0; i$1 <= 7; ++i$1) {
    let item$1 = Belt_Option.flatMap(Belt_Array.get(displayDollKind.dyes, i$1), a => a);
    if (item$1 !== undefined) {
      packDisplayItem(writer, item$1);
    }
  }
  return writer;
}

function packHatRack(writer, hatRackKind) {
  let flags = BitFlags$TerrariaPacket.fromFlags(hasItem(hatRackKind.items, 0), hasItem(hatRackKind.items, 1), hasItem(hatRackKind.dyes, 2), hasItem(hatRackKind.dyes, 3), false, false, false, false);
  ErrorAwareBufferWriter$TerrariaPacket.packByte(writer, BitFlags$TerrariaPacket.toByte(flags), "flags");
  for (let i = 0; i <= 1; ++i) {
    let item = Belt_Option.flatMap(Belt_Array.get(hatRackKind.items, i), a => a);
    if (item !== undefined) {
      packDisplayItem(writer, item);
    }
  }
  for (let i$1 = 0; i$1 <= 1; ++i$1) {
    let item$1 = Belt_Option.flatMap(Belt_Array.get(hatRackKind.dyes, i$1), a => a);
    if (item$1 !== undefined) {
      packDisplayItem(writer, item$1);
    }
  }
  return writer;
}

function packTeleportationPylon(writer, _teleportationPylonKind) {
  return writer;
}

function packEntityKind(writer, entityKind) {
  switch (entityKind.TAG) {
    case "DisplayDoll" :
      return packDisplayDoll(writer, entityKind._0);
    case "HatRack" :
      return packHatRack(writer, entityKind._0);
    case "LogicSensor" :
      return packLogicSensor(writer, entityKind._0);
    case "TeleportationPylon" :
      return writer;
    case "TrainingDummy" :
      return packTrainingDummy(writer, entityKind._0);
    case "FoodPlatter" :
    case "ItemFrame" :
    case "WeaponsRack" :
      return packDisplayItem(writer, entityKind._0);
  }
}

function pack$2(writer, entity) {
  return packEntityKind(ErrorAwareBufferWriter$TerrariaPacket.packInt16(ErrorAwareBufferWriter$TerrariaPacket.packInt16(ErrorAwareBufferWriter$TerrariaPacket.packByte(writer, entity.entityType, "entityType"), entity.x, "x"), entity.y, "y"), entity.entityKind);
}

let Entity = {
  readInt16: ErrorAwareBufferReader$TerrariaPacket.readInt16,
  readByte: ErrorAwareBufferReader$TerrariaPacket.readByte,
  parseTrainingDummyKind: parseTrainingDummyKind,
  parseDisplayItem: parseDisplayItem,
  parseItemFrameKind: parseDisplayItem,
  parseLogicSensorKind: parseLogicSensorKind,
  parseDisplayDollKind: parseDisplayDollKind,
  parseWeaponsRackKind: parseDisplayItem,
  parseHatRackKind: parseHatRackKind,
  parseFoodPlatterKind: parseDisplayItem,
  parse: parse$2,
  packByte: ErrorAwareBufferWriter$TerrariaPacket.packByte,
  packInt16: ErrorAwareBufferWriter$TerrariaPacket.packInt16,
  packTrainingDummy: packTrainingDummy,
  packDisplayItem: packDisplayItem,
  packItemFrame: packDisplayItem,
  packLogicSensor: packLogicSensor,
  hasItem: hasItem,
  packDisplayDoll: packDisplayDoll,
  packWeaponsRack: packDisplayItem,
  packHatRack: packHatRack,
  packFoodPlatter: packDisplayItem,
  packTeleportationPylon: packTeleportationPylon,
  packEntityKind: packEntityKind,
  pack: pack$2
};

let isTheSameAs = Primitive_object.equal;

function clearTileCache(tile) {
  tile.activeTile = undefined;
  tile.color = undefined;
  tile.wallColor = undefined;
  tile.wall = undefined;
  tile.liquid = undefined;
  tile.lava = false;
  tile.honey = false;
  tile.wire = false;
  tile.wire2 = false;
  tile.wire3 = false;
  tile.wire4 = false;
  tile.halfBrick = false;
  tile.slope = undefined;
  tile.actuator = false;
  tile.inActive = false;
}

function readRepeated(count, parseItem) {
  let items = [];
  let parseResult = {
    TAG: "Ok",
    _0: undefined
  };
  for (let _i = 0; _i < count; ++_i) {
    let match = parseResult;
    if (match.TAG === "Ok") {
      let item = parseItem();
      if (item.TAG === "Ok") {
        items.push(item._0);
      } else {
        parseResult = {
          TAG: "Error",
          _0: item._0
        };
      }
    }
  }
  let err = parseResult;
  if (err.TAG === "Ok") {
    return {
      TAG: "Ok",
      _0: items
    };
  } else {
    return {
      TAG: "Error",
      _0: err._0
    };
  }
}

function parse$3(payload) {
  let packetReader = new Packetreader(payload);
  let e = ErrorAwarePacketReader$TerrariaPacket.getBytesLeft(packetReader);
  if (e.TAG !== "Ok") {
    return e;
  }
  let e$1 = ErrorAwarePacketReader$TerrariaPacket.readBuffer(packetReader, e._0, "deflatedPayload");
  if (e$1.TAG !== "Ok") {
    return e$1;
  }
  let inflated;
  try {
    inflated = {
      TAG: "Ok",
      _0: Nodezlib.inflateRawSync(e$1._0)
    };
  } catch (raw_obj) {
    let obj = Primitive_exceptions.internalToException(raw_obj);
    if (obj.RE_EXN_ID === "JsExn") {
      inflated = {
        TAG: "Error",
        _0: {
          context: "inflateRawSync",
          error: obj._1
        }
      };
    } else {
      throw obj;
    }
  }
  if (inflated.TAG !== "Ok") {
    return inflated;
  }
  let reader = new Bufferreader(inflated._0);
  let e$2 = ErrorAwareBufferReader$TerrariaPacket.readInt32(reader, "tileX");
  if (e$2.TAG !== "Ok") {
    return e$2;
  }
  let e$3 = ErrorAwareBufferReader$TerrariaPacket.readInt32(reader, "tileY");
  if (e$3.TAG !== "Ok") {
    return e$3;
  }
  let e$4 = ErrorAwareBufferReader$TerrariaPacket.readInt16(reader, "width");
  if (e$4.TAG !== "Ok") {
    return e$4;
  }
  let width = e$4._0;
  let e$5 = ErrorAwareBufferReader$TerrariaPacket.readInt16(reader, "height");
  if (e$5.TAG !== "Ok") {
    return e$5;
  }
  let height = e$5._0;
  let tiles = [];
  let tileCache = defaultTileCache();
  let rleCount = {
    contents: 0
  };
  if (height < 0 || width < 0) {
    return {
      TAG: "Error",
      _0: {
        context: "Packet_TileSectionSend.parse",
        error: new Error("Tile section dimensions must be non-negative")
      }
    };
  }
  let parseResult = {
    TAG: "Ok",
    _0: undefined
  };
  let readTile = () => {
    clearTileCache(tileCache);
    let e = ErrorAwareBufferReader$TerrariaPacket.readByte(reader, "header5");
    if (e.TAG !== "Ok") {
      return e;
    }
    let header5 = BitFlags$TerrariaPacket.fromByte(e._0);
    let e$1;
    if (BitFlags$TerrariaPacket.flag1(header5)) {
      let e$2 = ErrorAwareBufferReader$TerrariaPacket.readByte(reader, "header4_conditional");
      if (e$2.TAG === "Ok") {
        let header4 = BitFlags$TerrariaPacket.fromByte(e$2._0);
        let e$3;
        if (BitFlags$TerrariaPacket.flag1(header4)) {
          let e$4 = ErrorAwareBufferReader$TerrariaPacket.readByte(reader, "header3_conditional");
          if (e$4.TAG === "Ok") {
            let header3 = BitFlags$TerrariaPacket.fromByte(e$4._0);
            let e$5 = BitFlags$TerrariaPacket.flag1(header3) ? ErrorAwareBufferReader$TerrariaPacket.readByte(reader, "header2_conditional") : ({
                TAG: "Ok",
                _0: 0
              });
            e$3 = e$5.TAG === "Ok" ? ({
                TAG: "Ok",
                _0: [
                  header3,
                  e$5._0
                ]
              }) : e$5;
          } else {
            e$3 = e$4;
          }
        } else {
          e$3 = {
            TAG: "Ok",
            _0: [
              BitFlags$TerrariaPacket.fromByte(0),
              0
            ]
          };
        }
        if (e$3.TAG === "Ok") {
          let match = e$3._0;
          e$1 = {
            TAG: "Ok",
            _0: [
              header4,
              match[0],
              match[1]
            ]
          };
        } else {
          e$1 = e$3;
        }
      } else {
        e$1 = e$2;
      }
    } else {
      e$1 = {
        TAG: "Ok",
        _0: [
          BitFlags$TerrariaPacket.fromByte(0),
          BitFlags$TerrariaPacket.fromByte(0),
          0
        ]
      };
    }
    if (e$1.TAG !== "Ok") {
      return e$1;
    }
    let match$1 = e$1._0;
    let header3$1 = match$1[1];
    let header4$1 = match$1[0];
    tileCache.coatHeader = match$1[2];
    let oldActive = tileCache.activeTile;
    let e$6;
    if (BitFlags$TerrariaPacket.flag2(header5)) {
      let oldType = Belt_Option.mapWithDefault(tileCache.activeTile, 0, active => active.tileType);
      let e$7;
      if (BitFlags$TerrariaPacket.flag6(header5)) {
        let e$8 = ErrorAwareBufferReader$TerrariaPacket.readByte(reader, "tileType_byte1");
        if (e$8.TAG === "Ok") {
          let e$9 = ErrorAwareBufferReader$TerrariaPacket.readByte(reader, "tileType_byte2");
          e$7 = e$9.TAG === "Ok" ? ({
              TAG: "Ok",
              _0: (e$9._0 << 8) | e$8._0
            }) : e$9;
        } else {
          e$7 = e$8;
        }
      } else {
        e$7 = ErrorAwareBufferReader$TerrariaPacket.readByte(reader, "tileType");
      }
      if (e$7.TAG === "Ok") {
        let tileType = e$7._0;
        let e$10;
        if (TileFrameImportant$TerrariaPacket.isImportant(tileType)) {
          let e$11 = ErrorAwareBufferReader$TerrariaPacket.readInt16(reader, "frameX");
          if (e$11.TAG === "Ok") {
            let e$12 = ErrorAwareBufferReader$TerrariaPacket.readInt16(reader, "frameY");
            e$10 = e$12.TAG === "Ok" ? ({
                TAG: "Ok",
                _0: {
                  x: e$11._0,
                  y: e$12._0
                }
              }) : e$12;
          } else {
            e$10 = e$11;
          }
        } else {
          e$10 = Belt_Option.isSome(oldActive) && tileType === oldType ? ({
              TAG: "Ok",
              _0: oldActive.frame
            }) : ({
              TAG: "Ok",
              _0: undefined
            });
        }
        if (e$10.TAG === "Ok") {
          let e$13;
          if (BitFlags$TerrariaPacket.flag4(header3$1)) {
            let e$14 = ErrorAwareBufferReader$TerrariaPacket.readByte(reader, "color");
            if (e$14.TAG === "Ok") {
              tileCache.color = e$14._0;
              e$13 = {
                TAG: "Ok",
                _0: undefined
              };
            } else {
              e$13 = e$14;
            }
          } else {
            e$13 = {
              TAG: "Ok",
              _0: undefined
            };
          }
          if (e$13.TAG === "Ok") {
            tileCache.activeTile = {
              tileType: tileType,
              frame: e$10._0
            };
            e$6 = {
              TAG: "Ok",
              _0: undefined
            };
          } else {
            e$6 = e$13;
          }
        } else {
          e$6 = e$10;
        }
      } else {
        e$6 = e$7;
      }
    } else {
      e$6 = {
        TAG: "Ok",
        _0: undefined
      };
    }
    if (e$6.TAG !== "Ok") {
      return e$6;
    }
    let e$15;
    if (BitFlags$TerrariaPacket.flag3(header5)) {
      let e$16 = ErrorAwareBufferReader$TerrariaPacket.readByte(reader, "wall");
      if (e$16.TAG === "Ok") {
        tileCache.wall = e$16._0;
        if (BitFlags$TerrariaPacket.flag5(header3$1)) {
          let e$17 = ErrorAwareBufferReader$TerrariaPacket.readByte(reader, "wallColor");
          if (e$17.TAG === "Ok") {
            tileCache.wallColor = e$17._0;
            e$15 = {
              TAG: "Ok",
              _0: undefined
            };
          } else {
            e$15 = e$17;
          }
        } else {
          e$15 = {
            TAG: "Ok",
            _0: undefined
          };
        }
      } else {
        e$15 = e$16;
      }
    } else {
      e$15 = {
        TAG: "Ok",
        _0: undefined
      };
    }
    if (e$15.TAG !== "Ok") {
      return e$15;
    }
    let liquidBits = ((BitFlags$TerrariaPacket.toByte(header5) & 24) >> 3);
    let e$18;
    if (liquidBits !== 0) {
      let e$19 = ErrorAwareBufferReader$TerrariaPacket.readByte(reader, "liquidValue");
      if (e$19.TAG === "Ok") {
        tileCache.liquid = e$19._0;
        if (liquidBits > 1) {
          if (liquidBits === 2) {
            tileCache.lava = true;
          } else {
            tileCache.honey = true;
          }
        }
        e$18 = {
          TAG: "Ok",
          _0: undefined
        };
      } else {
        e$18 = e$19;
      }
    } else {
      e$18 = {
        TAG: "Ok",
        _0: undefined
      };
    }
    if (e$18.TAG !== "Ok") {
      return e$18;
    }
    if (BitFlags$TerrariaPacket.toByte(header4$1) > 1) {
      if (BitFlags$TerrariaPacket.flag2(header4$1)) {
        tileCache.wire = true;
      }
      if (BitFlags$TerrariaPacket.flag3(header4$1)) {
        tileCache.wire2 = true;
      }
      if (BitFlags$TerrariaPacket.flag4(header4$1)) {
        tileCache.wire3 = true;
      }
      let slopeBits = ((BitFlags$TerrariaPacket.toByte(header4$1) & 112) >> 4);
      if (slopeBits !== 0 && TileSolid$TerrariaPacket.isSolid(Belt_Option.mapWithDefault(tileCache.activeTile, 0, tile => tile.tileType))) {
        if (slopeBits === 1) {
          tileCache.halfBrick = true;
        } else {
          tileCache.slope = slopeBits - 1 | 0;
        }
      }
    }
    let e$20;
    if (BitFlags$TerrariaPacket.toByte(header3$1) > 0) {
      if (BitFlags$TerrariaPacket.flag2(header3$1)) {
        tileCache.actuator = true;
      }
      if (BitFlags$TerrariaPacket.flag3(header3$1)) {
        tileCache.inActive = true;
      }
      if (BitFlags$TerrariaPacket.flag6(header3$1)) {
        tileCache.wire4 = true;
      }
      let e$21;
      if (BitFlags$TerrariaPacket.flag7(header3$1)) {
        let e$22 = ErrorAwareBufferReader$TerrariaPacket.readByte(reader, "wall_highByte");
        if (e$22.TAG === "Ok") {
          tileCache.wall = (e$22._0 << 8) | tileCache.wall;
          e$21 = {
            TAG: "Ok",
            _0: undefined
          };
        } else {
          e$21 = e$22;
        }
      } else {
        e$21 = {
          TAG: "Ok",
          _0: undefined
        };
      }
      e$20 = e$21.TAG === "Ok" ? ({
          TAG: "Ok",
          _0: undefined
        }) : e$21;
    } else {
      e$20 = {
        TAG: "Ok",
        _0: undefined
      };
    }
    if (e$20.TAG !== "Ok") {
      return e$20;
    }
    let repeatCountBytes = ((BitFlags$TerrariaPacket.toByte(header5) & 192) >> 6);
    let e$23;
    if (repeatCountBytes !== 0) {
      if (repeatCountBytes !== 1) {
        let e$24 = ErrorAwareBufferReader$TerrariaPacket.readInt16(reader, "rle_int16");
        if (e$24.TAG === "Ok") {
          rleCount.contents = e$24._0;
          e$23 = {
            TAG: "Ok",
            _0: undefined
          };
        } else {
          e$23 = e$24;
        }
      } else {
        let e$25 = ErrorAwareBufferReader$TerrariaPacket.readByte(reader, "rle_byte");
        if (e$25.TAG === "Ok") {
          rleCount.contents = e$25._0;
          e$23 = {
            TAG: "Ok",
            _0: undefined
          };
        } else {
          e$23 = e$25;
        }
      }
    } else {
      rleCount.contents = 0;
      e$23 = {
        TAG: "Ok",
        _0: undefined
      };
    }
    if (e$23.TAG === "Ok") {
      return {
        TAG: "Ok",
        _0: cacheToTile(tileCache)
      };
    } else {
      return e$23;
    }
  };
  for (let _y = 0; _y < height; ++_y) {
    let match = parseResult;
    if (match.TAG === "Ok") {
      let row = [];
      for (let _x = 0; _x < width; ++_x) {
        let match$1 = parseResult;
        if (match$1.TAG === "Ok") {
          if (rleCount.contents !== 0) {
            rleCount.contents = rleCount.contents - 1 | 0;
            row.push(cacheToTile(tileCache));
          } else {
            let tile = readTile();
            if (tile.TAG === "Ok") {
              row.push(tile._0);
            } else {
              parseResult = {
                TAG: "Error",
                _0: tile._0
              };
            }
          }
        }
      }
      let match$2 = parseResult;
      if (match$2.TAG === "Ok") {
        tiles.push(row);
      }
    }
  }
  let err = parseResult;
  if (err.TAG !== "Ok") {
    return {
      TAG: "Error",
      _0: err._0
    };
  }
  let e$6 = ErrorAwareBufferReader$TerrariaPacket.readInt16(reader, "chestCount");
  if (e$6.TAG !== "Ok") {
    return e$6;
  }
  let e$7 = readRepeated(e$6._0, () => parse(reader));
  if (e$7.TAG !== "Ok") {
    return e$7;
  }
  let e$8 = ErrorAwareBufferReader$TerrariaPacket.readInt16(reader, "signCount");
  if (e$8.TAG !== "Ok") {
    return e$8;
  }
  let e$9 = readRepeated(e$8._0, () => parse$1(reader));
  if (e$9.TAG !== "Ok") {
    return e$9;
  }
  let e$10 = ErrorAwareBufferReader$TerrariaPacket.readInt16(reader, "entityCount");
  if (e$10.TAG !== "Ok") {
    return e$10;
  }
  let e$11 = readRepeated(e$10._0, () => parse$2(reader));
  if (e$11.TAG === "Ok") {
    return {
      TAG: "Ok",
      _0: {
        height: height,
        width: width,
        tileX: e$2._0,
        tileY: e$3._0,
        tiles: tiles,
        chests: e$7._0,
        signs: e$9._0,
        entities: e$11._0
      }
    };
  } else {
    return e$11;
  }
}

let Decode = {
  clearTileCache: clearTileCache,
  PacketReader: undefined,
  readBuffer: ErrorAwarePacketReader$TerrariaPacket.readBuffer,
  getBytesLeft: ErrorAwarePacketReader$TerrariaPacket.getBytesLeft,
  readInt16: ErrorAwareBufferReader$TerrariaPacket.readInt16,
  readInt32: ErrorAwareBufferReader$TerrariaPacket.readInt32,
  readByte: ErrorAwareBufferReader$TerrariaPacket.readByte,
  readRepeated: readRepeated,
  parse: parse$3
};

function getLiquidBitFlags(tile) {
  let liquidBits = tile.honey ? "Three" : (
      tile.lava ? "Two" : (
          Belt_Option.isSome(tile.liquid) ? "One" : "Zero"
        )
    );
  switch (liquidBits) {
    case "Zero" :
      return [
        false,
        false
      ];
    case "One" :
      return [
        false,
        true
      ];
    case "Two" :
      return [
        true,
        false
      ];
    case "Three" :
      return [
        true,
        true
      ];
  }
}

function getSlopeBitFlags(tile) {
  if (tile.halfBrick) {
    return [
      false,
      false,
      true
    ];
  }
  let match = tile.slope;
  if (match === undefined) {
    return [
      false,
      false,
      false
    ];
  }
  switch (match) {
    case 0 :
      return [
        false,
        false,
        true
      ];
    case 1 :
      return [
        false,
        true,
        false
      ];
    case 2 :
      return [
        false,
        true,
        true
      ];
    case 3 :
      return [
        true,
        false,
        false
      ];
    case 4 :
      return [
        true,
        false,
        true
      ];
    case 5 :
      return [
        true,
        true,
        false
      ];
    default:
      return [
        true,
        true,
        true
      ];
  }
}

function getRepeatCountByteLength(repeatCount) {
  if (repeatCount > 255) {
    return 2;
  } else if (repeatCount > 0) {
    return 1;
  } else {
    return 0;
  }
}

function getRepeatCountBitFlags(repeatCount) {
  let repeatCountBytes = getRepeatCountByteLength(repeatCount);
  switch (repeatCountBytes) {
    case 0 :
      return [
        false,
        false
      ];
    case 1 :
      return [
        false,
        true
      ];
    default:
      return [
        true,
        false
      ];
  }
}

function packTile(writer, tile, repeatCount) {
  let header2 = tile.coatHeader;
  let wall = tile.wall;
  let header3 = BitFlags$TerrariaPacket.fromFlags(header2 > 0, tile.actuator, tile.inActive, Belt_Option.isSome(tile.color), Belt_Option.isSome(tile.wall) && Belt_Option.isSome(tile.wallColor), tile.wire4, wall !== undefined ? wall > 255 : false, false);
  let match = getSlopeBitFlags(tile);
  let header4 = BitFlags$TerrariaPacket.fromFlags(BitFlags$TerrariaPacket.toByte(header3) > 0, tile.wire, tile.wire2, tile.wire3, match[2], match[1], match[0], false);
  let match$1 = getLiquidBitFlags(tile);
  let match$2 = getRepeatCountBitFlags(repeatCount);
  let activeTile = tile.activeTile;
  let tileFlags = BitFlags$TerrariaPacket.fromFlags(BitFlags$TerrariaPacket.toByte(header4) > 0, Belt_Option.isSome(tile.activeTile), Belt_Option.isSome(tile.wall), match$1[1], match$1[0], activeTile !== undefined ? activeTile.tileType > 255 : false, match$2[1], match$2[0]);
  ErrorAwareBufferWriter$TerrariaPacket.packByte(writer, BitFlags$TerrariaPacket.toByte(tileFlags), "tileFlags");
  if (BitFlags$TerrariaPacket.flag1(tileFlags)) {
    ErrorAwareBufferWriter$TerrariaPacket.packByte(writer, BitFlags$TerrariaPacket.toByte(header4), "header4");
    if (BitFlags$TerrariaPacket.flag1(header4)) {
      ErrorAwareBufferWriter$TerrariaPacket.packByte(writer, BitFlags$TerrariaPacket.toByte(header3), "header3");
      if (BitFlags$TerrariaPacket.flag1(header3)) {
        ErrorAwareBufferWriter$TerrariaPacket.packByte(writer, header2, "header2");
      }
    }
  }
  let activeTile$1 = tile.activeTile;
  if (activeTile$1 !== undefined) {
    if (BitFlags$TerrariaPacket.flag6(tileFlags)) {
      ErrorAwareBufferWriter$TerrariaPacket.packByte(writer, activeTile$1.tileType & 255, "tileType_lowByte");
      ErrorAwareBufferWriter$TerrariaPacket.packByte(writer, ((activeTile$1.tileType & 65280) >> 8), "tileType_highByte");
    } else {
      ErrorAwareBufferWriter$TerrariaPacket.packByte(writer, activeTile$1.tileType, "tileType");
    }
    let match$3 = activeTile$1.frame;
    if (match$3 !== undefined) {
      ErrorAwareBufferWriter$TerrariaPacket.packInt16(writer, match$3.x, "frameX");
      ErrorAwareBufferWriter$TerrariaPacket.packInt16(writer, match$3.y, "frameY");
    }
    let color = tile.color;
    if (color !== undefined) {
      ErrorAwareBufferWriter$TerrariaPacket.packByte(writer, color, "color");
    }
  }
  let wall$1 = tile.wall;
  if (wall$1 !== undefined) {
    ErrorAwareBufferWriter$TerrariaPacket.packByte(writer, wall$1 & 255, "wall_lowByte");
    let wallColor = tile.wallColor;
    if (wallColor !== undefined) {
      ErrorAwareBufferWriter$TerrariaPacket.packByte(writer, wallColor, "wallColor");
    }
  }
  let liquid = tile.liquid;
  if (liquid !== undefined) {
    ErrorAwareBufferWriter$TerrariaPacket.packByte(writer, liquid, "liquidValue");
  }
  let wall$2 = tile.wall;
  if (wall$2 !== undefined && wall$2 > 255) {
    ErrorAwareBufferWriter$TerrariaPacket.packByte(writer, (wall$2 >> 8), "wall_highByte");
  }
  let match$4 = getRepeatCountByteLength(repeatCount);
  if (match$4 !== 0) {
    if (match$4 !== 1) {
      ErrorAwareBufferWriter$TerrariaPacket.packInt16(writer, repeatCount, "rle_int16");
    } else {
      ErrorAwareBufferWriter$TerrariaPacket.packByte(writer, repeatCount, "rle_byte");
    }
  }
  return writer;
}

function decidePackTile(writer, lastTile, tile) {
  let last = lastTile.contents;
  if (last !== undefined) {
    if (Primitive_object.equal(tile, last.tile)) {
      last.count = last.count + 1 | 0;
    } else {
      packTile(writer, last.tile, last.count);
      lastTile.contents = {
        tile: tile,
        count: 0
      };
    }
  } else {
    lastTile.contents = {
      tile: tile,
      count: 0
    };
  }
}

function toBuffer(self) {
  let outerPacketWriter = ErrorAwarePacketWriter$TerrariaPacket.setType(ErrorAwarePacketWriter$TerrariaPacket.make(), PacketType$TerrariaPacket.toInt("TileSectionSend"));
  let innerWriter = ErrorAwareBufferWriter$TerrariaPacket.make(Buffer.allocUnsafe(64000));
  ErrorAwareBufferWriter$TerrariaPacket.packInt16(ErrorAwareBufferWriter$TerrariaPacket.packInt16(ErrorAwareBufferWriter$TerrariaPacket.packInt32(ErrorAwareBufferWriter$TerrariaPacket.packInt32(innerWriter, self.tileX, "tileX"), self.tileY, "tileY"), self.width, "width"), self.height, "height");
  let lastTile = {
    contents: undefined
  };
  for (let y = 0, y_finish = self.height; y < y_finish; ++y) {
    for (let x = 0, x_finish = self.width; x < x_finish; ++x) {
      let tile = self.tiles[y][x];
      decidePackTile(innerWriter, lastTile, tile);
    }
  }
  let lastTileValue = lastTile.contents;
  if (lastTileValue !== undefined) {
    packTile(innerWriter, lastTileValue.tile, lastTileValue.count);
  }
  ErrorAwareBufferWriter$TerrariaPacket.packInt16(innerWriter, self.chests.length, "chestCount");
  self.chests.forEach(chest => {
    pack(innerWriter, chest);
  });
  ErrorAwareBufferWriter$TerrariaPacket.packInt16(innerWriter, self.signs.length, "signCount");
  self.signs.forEach(sign => {
    pack$1(innerWriter, sign);
  });
  ErrorAwareBufferWriter$TerrariaPacket.packInt16(innerWriter, self.entities.length, "entityCount");
  self.entities.forEach(entity => {
    pack$2(innerWriter, entity);
  });
  let innerBuffer = ErrorAwareBufferWriter$TerrariaPacket.data(innerWriter);
  if (innerBuffer.TAG === "Ok") {
    let deflatedPayload = Nodezlib.deflateRawSync(innerBuffer._0);
    return ErrorAwarePacketWriter$TerrariaPacket.data(ErrorAwarePacketWriter$TerrariaPacket.packBuffer(outerPacketWriter, deflatedPayload, "deflatedPayload"));
  }
  let e = innerBuffer._0;
  return {
    TAG: "Error",
    _0: {
      context: "innerWriter; " + e.context,
      error: e.error
    }
  };
}

let Encode = {
  setType: ErrorAwarePacketWriter$TerrariaPacket.setType,
  packBuffer: ErrorAwarePacketWriter$TerrariaPacket.packBuffer,
  packByte: ErrorAwareBufferWriter$TerrariaPacket.packByte,
  packInt16: ErrorAwareBufferWriter$TerrariaPacket.packInt16,
  packInt32: ErrorAwareBufferWriter$TerrariaPacket.packInt32,
  data: ErrorAwareBufferWriter$TerrariaPacket.data,
  getLiquidBitFlags: getLiquidBitFlags,
  getSlopeBitFlags: getSlopeBitFlags,
  getRepeatCountByteLength: getRepeatCountByteLength,
  getRepeatCountBitFlags: getRepeatCountBitFlags,
  packTile: packTile,
  decidePackTile: decidePackTile,
  toBuffer: toBuffer
};

let Int;

let Option;

exports.Int = Int;
exports.Option = Option;
exports.defaultTileCache = defaultTileCache;
exports.cacheToTile = cacheToTile;
exports.Chest = Chest;
exports.Sign = Sign;
exports.Entity = Entity;
exports.isTheSameAs = isTheSameAs;
exports.Decode = Decode;
exports.Encode = Encode;
exports.parse = parse$3;
exports.toBuffer = toBuffer;
/* node:zlib Not a pure module */
