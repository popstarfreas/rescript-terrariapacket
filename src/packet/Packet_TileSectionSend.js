// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Caml_obj = require("rescript/lib/js/caml_obj.js");
var Nodezlib = require("node:zlib");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Belt_Result = require("rescript/lib/js/belt_Result.js");
var BitFlags$TerrariaPacket = require("../BitFlags.js");
var ResultExt$TerrariaPacket = require("../ResultExt.js");
var TileSolid$TerrariaPacket = require("../TileSolid.js");
var PacketType$TerrariaPacket = require("../PacketType.js");
var TileFrameImportant$TerrariaPacket = require("../TileFrameImportant.js");
var ErrorAwareBufferReader$TerrariaPacket = require("../ErrorAwareBufferReader.js");
var ErrorAwareBufferWriter$TerrariaPacket = require("../ErrorAwareBufferWriter.js");
var ErrorAwarePacketReader$TerrariaPacket = require("../ErrorAwarePacketReader.js");
var ErrorAwarePacketWriter$TerrariaPacket = require("../ErrorAwarePacketWriter.js");
var Bufferreader = require("@popstarfreas/packetfactory/bufferreader").default;
var Packetreader = require("@popstarfreas/packetfactory/packetreader").default;

function defaultTileCache() {
  return {
          activeTile: undefined,
          color: undefined,
          wallColor: undefined,
          wall: undefined,
          liquid: undefined,
          lava: false,
          honey: false,
          wire: false,
          wire2: false,
          wire3: false,
          wire4: false,
          halfBrick: false,
          slope: undefined,
          actuator: false,
          inActive: false,
          coatHeader: 0
        };
}

function cacheToTile(cache) {
  return {
          activeTile: cache.activeTile,
          color: cache.color,
          wallColor: cache.wallColor,
          wall: cache.wall,
          liquid: cache.liquid,
          lava: cache.lava,
          honey: cache.honey,
          wire: cache.wire,
          wire2: cache.wire2,
          wire3: cache.wire3,
          wire4: cache.wire4,
          halfBrick: cache.halfBrick,
          slope: cache.slope,
          actuator: cache.actuator,
          inActive: cache.inActive,
          coatHeader: cache.coatHeader
        };
}

function parse(reader) {
  var id = ErrorAwareBufferReader$TerrariaPacket.readInt16(reader, "id");
  var x = ErrorAwareBufferReader$TerrariaPacket.readInt16(reader, "x");
  var y = ErrorAwareBufferReader$TerrariaPacket.readInt16(reader, "y");
  var name = ErrorAwareBufferReader$TerrariaPacket.readString(reader, "name");
  return {
          id: id,
          x: x,
          y: y,
          name: name
        };
}

function pack(writer, chest) {
  return ErrorAwareBufferWriter$TerrariaPacket.packString(ErrorAwareBufferWriter$TerrariaPacket.packInt16(ErrorAwareBufferWriter$TerrariaPacket.packInt16(ErrorAwareBufferWriter$TerrariaPacket.packInt16(writer, chest.id, "id"), chest.x, "x"), chest.y, "y"), chest.name, "name");
}

var Chest = {
  readString: ErrorAwareBufferReader$TerrariaPacket.readString,
  readInt16: ErrorAwareBufferReader$TerrariaPacket.readInt16,
  parse: parse,
  packInt16: ErrorAwareBufferWriter$TerrariaPacket.packInt16,
  packString: ErrorAwareBufferWriter$TerrariaPacket.packString,
  pack: pack
};

function parse$1(reader) {
  var id = ErrorAwareBufferReader$TerrariaPacket.readInt16(reader, "id");
  var x = ErrorAwareBufferReader$TerrariaPacket.readInt16(reader, "x");
  var y = ErrorAwareBufferReader$TerrariaPacket.readInt16(reader, "y");
  var name = ErrorAwareBufferReader$TerrariaPacket.readString(reader, "name");
  return {
          id: id,
          x: x,
          y: y,
          name: name
        };
}

function pack$1(writer, sign) {
  return ErrorAwareBufferWriter$TerrariaPacket.packString(ErrorAwareBufferWriter$TerrariaPacket.packInt16(ErrorAwareBufferWriter$TerrariaPacket.packInt16(ErrorAwareBufferWriter$TerrariaPacket.packInt16(writer, sign.id, "id"), sign.x, "x"), sign.y, "y"), sign.name, "name");
}

var Sign = {
  readString: ErrorAwareBufferReader$TerrariaPacket.readString,
  readInt16: ErrorAwareBufferReader$TerrariaPacket.readInt16,
  parse: parse$1,
  packInt16: ErrorAwareBufferWriter$TerrariaPacket.packInt16,
  packString: ErrorAwareBufferWriter$TerrariaPacket.packString,
  pack: pack$1
};

function parseTrainingDummyKind(reader) {
  return {
          npcSlotId: ErrorAwareBufferReader$TerrariaPacket.readInt16(reader, "npcSlotId")
        };
}

function parseDisplayItem(reader) {
  var netId = ErrorAwareBufferReader$TerrariaPacket.readInt16(reader, "netId");
  var prefix = ErrorAwareBufferReader$TerrariaPacket.readByte(reader, "prefix");
  var stack = ErrorAwareBufferReader$TerrariaPacket.readInt16(reader, "stack");
  return {
          netId: netId,
          prefix: prefix,
          stack: stack
        };
}

function parseLogicSensorKind(reader) {
  var checkType = ErrorAwareBufferReader$TerrariaPacket.readByte(reader, "checkType");
  var on = ErrorAwareBufferReader$TerrariaPacket.readByte(reader, "on") === 1;
  return {
          checkType: checkType,
          on: on
        };
}

function parseDisplayDollKind(reader) {
  var itemsFlags = BitFlags$TerrariaPacket.fromByte(ErrorAwareBufferReader$TerrariaPacket.readByte(reader, "itemsFlags"));
  var dyeFlags = BitFlags$TerrariaPacket.fromByte(ErrorAwareBufferReader$TerrariaPacket.readByte(reader, "dyeFlags"));
  var items = [];
  var dyes = [];
  for(var i = 0; i <= 7; ++i){
    if (BitFlags$TerrariaPacket.flagN(itemsFlags, i)) {
      items.push(parseDisplayItem(reader));
    } else {
      items.push(undefined);
    }
  }
  for(var i$1 = 0; i$1 <= 7; ++i$1){
    if (BitFlags$TerrariaPacket.flagN(dyeFlags, i$1)) {
      dyes.push(parseDisplayItem(reader));
    } else {
      dyes.push(undefined);
    }
  }
  return {
          items: items,
          dyes: dyes
        };
}

function parseHatRackKind(reader) {
  var flags = BitFlags$TerrariaPacket.fromByte(ErrorAwareBufferReader$TerrariaPacket.readByte(reader, "flags"));
  var items = [];
  var dyes = [];
  for(var i = 0; i <= 1; ++i){
    if (BitFlags$TerrariaPacket.flagN(flags, i)) {
      items.push(parseDisplayItem(reader));
    } else {
      items.push(undefined);
    }
  }
  for(var i$1 = 0; i$1 <= 1; ++i$1){
    if (BitFlags$TerrariaPacket.flagN(flags, i$1 + 2 | 0)) {
      dyes.push(parseDisplayItem(reader));
    } else {
      dyes.push(undefined);
    }
  }
  return {
          items: items,
          dyes: dyes
        };
}

function parse$2(reader) {
  var entityType = ErrorAwareBufferReader$TerrariaPacket.readByte(reader, "entityType");
  var x = ErrorAwareBufferReader$TerrariaPacket.readInt16(reader, "x");
  var y = ErrorAwareBufferReader$TerrariaPacket.readInt16(reader, "y");
  var entityKind;
  switch (entityType) {
    case 0 :
        entityKind = {
          TAG: "Ok",
          _0: {
            TAG: "TrainingDummy",
            _0: parseTrainingDummyKind(reader)
          }
        };
        break;
    case 1 :
        entityKind = {
          TAG: "Ok",
          _0: {
            TAG: "ItemFrame",
            _0: parseDisplayItem(reader)
          }
        };
        break;
    case 2 :
        entityKind = {
          TAG: "Ok",
          _0: {
            TAG: "LogicSensor",
            _0: parseLogicSensorKind(reader)
          }
        };
        break;
    case 3 :
        entityKind = {
          TAG: "Ok",
          _0: {
            TAG: "DisplayDoll",
            _0: parseDisplayDollKind(reader)
          }
        };
        break;
    case 4 :
        entityKind = {
          TAG: "Ok",
          _0: {
            TAG: "WeaponsRack",
            _0: parseDisplayItem(reader)
          }
        };
        break;
    case 5 :
        entityKind = {
          TAG: "Ok",
          _0: {
            TAG: "HatRack",
            _0: parseHatRackKind(reader)
          }
        };
        break;
    case 6 :
        entityKind = {
          TAG: "Ok",
          _0: {
            TAG: "FoodPlatter",
            _0: parseDisplayItem(reader)
          }
        };
        break;
    case 7 :
        entityKind = {
          TAG: "Ok",
          _0: {
            TAG: "TeleportationPylon",
            _0: undefined
          }
        };
        break;
    default:
      entityKind = {
        TAG: "Error",
        _0: "File \"Packet_TileSectionSend.res\", line 317, characters 17-24" + "Unknown entity kind. "
      };
  }
  return Belt_Result.map(entityKind, (function (entityKind) {
                return {
                        entityType: entityType,
                        x: x,
                        y: y,
                        entityKind: entityKind
                      };
              }));
}

function packTrainingDummy(writer, trainingDummy) {
  return ErrorAwareBufferWriter$TerrariaPacket.packInt16(writer, trainingDummy.npcSlotId, "npcSlotId");
}

function packDisplayItem(writer, displayItem) {
  return ErrorAwareBufferWriter$TerrariaPacket.packInt16(ErrorAwareBufferWriter$TerrariaPacket.packByte(ErrorAwareBufferWriter$TerrariaPacket.packInt16(writer, displayItem.netId, "netId"), displayItem.prefix, "prefix"), displayItem.stack, "stack");
}

function packLogicSensor(writer, logicSensorKind) {
  return ErrorAwareBufferWriter$TerrariaPacket.packByte(ErrorAwareBufferWriter$TerrariaPacket.packByte(writer, logicSensorKind.checkType, "checkType"), logicSensorKind.on ? 1 : 0, "on");
}

function hasItem(arr, n) {
  return Belt_Option.isSome(Belt_Option.flatMap(Belt_Array.get(arr, n), (function (a) {
                    return a;
                  })));
}

function packDisplayDoll(writer, displayDollKind) {
  var itemFlags = BitFlags$TerrariaPacket.fromFlags(hasItem(displayDollKind.items, 0), hasItem(displayDollKind.items, 1), hasItem(displayDollKind.items, 2), hasItem(displayDollKind.items, 3), hasItem(displayDollKind.items, 4), hasItem(displayDollKind.items, 5), hasItem(displayDollKind.items, 6), hasItem(displayDollKind.items, 7));
  var dyeFlags = BitFlags$TerrariaPacket.fromFlags(hasItem(displayDollKind.dyes, 0), hasItem(displayDollKind.dyes, 1), hasItem(displayDollKind.dyes, 2), hasItem(displayDollKind.dyes, 3), hasItem(displayDollKind.dyes, 4), hasItem(displayDollKind.dyes, 5), hasItem(displayDollKind.dyes, 6), hasItem(displayDollKind.dyes, 7));
  ErrorAwareBufferWriter$TerrariaPacket.packByte(ErrorAwareBufferWriter$TerrariaPacket.packByte(writer, BitFlags$TerrariaPacket.toByte(itemFlags), "itemFlags"), BitFlags$TerrariaPacket.toByte(dyeFlags), "dyeFlags");
  for(var i = 0; i <= 7; ++i){
    var item = Belt_Option.flatMap(Belt_Array.get(displayDollKind.items, i), (function (a) {
            return a;
          }));
    if (item !== undefined) {
      packDisplayItem(writer, item);
    }
    
  }
  for(var i$1 = 0; i$1 <= 7; ++i$1){
    var item$1 = Belt_Option.flatMap(Belt_Array.get(displayDollKind.dyes, i$1), (function (a) {
            return a;
          }));
    if (item$1 !== undefined) {
      packDisplayItem(writer, item$1);
    }
    
  }
  return writer;
}

function packHatRack(writer, hatRackKind) {
  var flags = BitFlags$TerrariaPacket.fromFlags(hasItem(hatRackKind.items, 0), hasItem(hatRackKind.items, 1), hasItem(hatRackKind.dyes, 2), hasItem(hatRackKind.dyes, 3), false, false, false, false);
  ErrorAwareBufferWriter$TerrariaPacket.packByte(writer, BitFlags$TerrariaPacket.toByte(flags), "flags");
  for(var i = 0; i <= 1; ++i){
    var item = Belt_Option.flatMap(Belt_Array.get(hatRackKind.items, i), (function (a) {
            return a;
          }));
    if (item !== undefined) {
      packDisplayItem(writer, item);
    }
    
  }
  for(var i$1 = 0; i$1 <= 1; ++i$1){
    var item$1 = Belt_Option.flatMap(Belt_Array.get(hatRackKind.dyes, i$1), (function (a) {
            return a;
          }));
    if (item$1 !== undefined) {
      packDisplayItem(writer, item$1);
    }
    
  }
  return writer;
}

function packTeleportationPylon(writer, _teleportationPylonKind) {
  return writer;
}

function packEntityKind(writer, entityKind) {
  switch (entityKind.TAG) {
    case "DisplayDoll" :
        return packDisplayDoll(writer, entityKind._0);
    case "HatRack" :
        return packHatRack(writer, entityKind._0);
    case "LogicSensor" :
        return packLogicSensor(writer, entityKind._0);
    case "TeleportationPylon" :
        return writer;
    case "TrainingDummy" :
        return packTrainingDummy(writer, entityKind._0);
    case "FoodPlatter" :
    case "ItemFrame" :
    case "WeaponsRack" :
        return packDisplayItem(writer, entityKind._0);
    
  }
}

function pack$2(writer, entity) {
  return packEntityKind(ErrorAwareBufferWriter$TerrariaPacket.packInt16(ErrorAwareBufferWriter$TerrariaPacket.packInt16(ErrorAwareBufferWriter$TerrariaPacket.packByte(writer, entity.entityType, "entityType"), entity.x, "x"), entity.y, "y"), entity.entityKind);
}

var Entity = {
  readInt16: ErrorAwareBufferReader$TerrariaPacket.readInt16,
  readByte: ErrorAwareBufferReader$TerrariaPacket.readByte,
  parseTrainingDummyKind: parseTrainingDummyKind,
  parseDisplayItem: parseDisplayItem,
  parseItemFrameKind: parseDisplayItem,
  parseLogicSensorKind: parseLogicSensorKind,
  parseDisplayDollKind: parseDisplayDollKind,
  parseWeaponsRackKind: parseDisplayItem,
  parseHatRackKind: parseHatRackKind,
  parseFoodPlatterKind: parseDisplayItem,
  parse: parse$2,
  packByte: ErrorAwareBufferWriter$TerrariaPacket.packByte,
  packInt16: ErrorAwareBufferWriter$TerrariaPacket.packInt16,
  packTrainingDummy: packTrainingDummy,
  packDisplayItem: packDisplayItem,
  packItemFrame: packDisplayItem,
  packLogicSensor: packLogicSensor,
  hasItem: hasItem,
  packDisplayDoll: packDisplayDoll,
  packWeaponsRack: packDisplayItem,
  packHatRack: packHatRack,
  packFoodPlatter: packDisplayItem,
  packTeleportationPylon: packTeleportationPylon,
  packEntityKind: packEntityKind,
  pack: pack$2
};

var isTheSameAs = Caml_obj.equal;

function clearTileCache(tile) {
  tile.activeTile = undefined;
  tile.color = undefined;
  tile.wallColor = undefined;
  tile.wall = undefined;
  tile.liquid = undefined;
  tile.lava = false;
  tile.honey = false;
  tile.wire = false;
  tile.wire2 = false;
  tile.wire3 = false;
  tile.wire4 = false;
  tile.halfBrick = false;
  tile.slope = undefined;
  tile.actuator = false;
  tile.inActive = false;
}

function parse$3(payload) {
  var packetReader = new Packetreader(payload);
  var deflated = ErrorAwarePacketReader$TerrariaPacket.readBuffer(packetReader, ErrorAwarePacketReader$TerrariaPacket.getBytesLeft(packetReader), "deflatedPayload");
  var reader = new Bufferreader(Nodezlib.inflateRawSync(deflated));
  var tileX = ErrorAwareBufferReader$TerrariaPacket.readInt32(reader, "tileX");
  var tileY = ErrorAwareBufferReader$TerrariaPacket.readInt32(reader, "tileY");
  var width = ErrorAwareBufferReader$TerrariaPacket.readInt16(reader, "width");
  var height = ErrorAwareBufferReader$TerrariaPacket.readInt16(reader, "height");
  var tiles = [];
  var tileCache = defaultTileCache();
  var rleCount = 0;
  if (height < 0 || width < 0) {
    return ;
  }
  for(var _y = 0; _y < height; ++_y){
    var row = [];
    for(var _x = 0; _x < width; ++_x){
      if (rleCount !== 0) {
        rleCount = rleCount - 1 | 0;
        row.push(cacheToTile(tileCache));
      } else {
        clearTileCache(tileCache);
        var header5 = BitFlags$TerrariaPacket.fromByte(ErrorAwareBufferReader$TerrariaPacket.readByte(reader, "header5"));
        var match;
        if (BitFlags$TerrariaPacket.flag1(header5)) {
          var header4 = BitFlags$TerrariaPacket.fromByte(ErrorAwareBufferReader$TerrariaPacket.readByte(reader, "header4_conditional"));
          var header3 = BitFlags$TerrariaPacket.flag1(header4) ? BitFlags$TerrariaPacket.fromByte(ErrorAwareBufferReader$TerrariaPacket.readByte(reader, "header3_conditional")) : BitFlags$TerrariaPacket.fromByte(0);
          var header2 = BitFlags$TerrariaPacket.flag1(header3) ? ErrorAwareBufferReader$TerrariaPacket.readByte(reader, "header2_conditional") : 0;
          match = [
            header4,
            header3,
            header2
          ];
        } else {
          match = [
            BitFlags$TerrariaPacket.fromByte(0),
            BitFlags$TerrariaPacket.fromByte(0),
            0
          ];
        }
        var header3$1 = match[1];
        var header4$1 = match[0];
        tileCache.coatHeader = match[2];
        var oldActive = tileCache.activeTile;
        if (BitFlags$TerrariaPacket.flag2(header5)) {
          var oldType = Belt_Option.mapWithDefault(tileCache.activeTile, 0, (function (active) {
                  return active.tileType;
                }));
          var tileType;
          if (BitFlags$TerrariaPacket.flag6(header5)) {
            var $$byte = ErrorAwareBufferReader$TerrariaPacket.readByte(reader, "tileType_byte1");
            var secondByte = ErrorAwareBufferReader$TerrariaPacket.readByte(reader, "tileType_byte2");
            tileType = (secondByte << 8) | $$byte;
          } else {
            tileType = ErrorAwareBufferReader$TerrariaPacket.readByte(reader, "tileType");
          }
          var frame;
          if (TileFrameImportant$TerrariaPacket.isImportant(tileType)) {
            var x = ErrorAwareBufferReader$TerrariaPacket.readInt16(reader, "frameX");
            var y = ErrorAwareBufferReader$TerrariaPacket.readInt16(reader, "frameY");
            frame = {
              x: x,
              y: y
            };
          } else {
            frame = Belt_Option.isSome(oldActive) && tileType === oldType ? oldActive.frame : undefined;
          }
          if (BitFlags$TerrariaPacket.flag4(header3$1)) {
            tileCache.color = ErrorAwareBufferReader$TerrariaPacket.readByte(reader, "color");
          }
          tileCache.activeTile = {
            tileType: tileType,
            frame: frame
          };
        }
        if (BitFlags$TerrariaPacket.flag3(header5)) {
          tileCache.wall = ErrorAwareBufferReader$TerrariaPacket.readByte(reader, "wall");
          if (BitFlags$TerrariaPacket.flag5(header3$1)) {
            tileCache.wallColor = ErrorAwareBufferReader$TerrariaPacket.readByte(reader, "wallColor");
          }
          
        }
        var liquidBits = ((BitFlags$TerrariaPacket.toByte(header5) & 24) >>> 3);
        if (liquidBits !== 0) {
          tileCache.liquid = ErrorAwareBufferReader$TerrariaPacket.readByte(reader, "liquidValue");
          if (liquidBits > 1) {
            if (liquidBits === 2) {
              tileCache.lava = true;
            } else {
              tileCache.honey = true;
            }
          }
          
        }
        if (BitFlags$TerrariaPacket.toByte(header4$1) > 1) {
          if (BitFlags$TerrariaPacket.flag2(header4$1)) {
            tileCache.wire = true;
          }
          if (BitFlags$TerrariaPacket.flag3(header4$1)) {
            tileCache.wire2 = true;
          }
          if (BitFlags$TerrariaPacket.flag4(header4$1)) {
            tileCache.wire3 = true;
          }
          var slopeBits = ((BitFlags$TerrariaPacket.toByte(header4$1) & 112) >>> 4);
          if (slopeBits !== 0 && TileSolid$TerrariaPacket.isSolid(Belt_Option.mapWithDefault(tileCache.activeTile, 0, (function (tile) {
                        return tile.tileType;
                      })))) {
            if (slopeBits === 1) {
              tileCache.halfBrick = true;
            } else {
              tileCache.slope = slopeBits - 1 | 0;
            }
          }
          
        }
        if (BitFlags$TerrariaPacket.toByte(header3$1) > 0) {
          if (BitFlags$TerrariaPacket.flag2(header3$1)) {
            tileCache.actuator = true;
          }
          if (BitFlags$TerrariaPacket.flag3(header3$1)) {
            tileCache.inActive = true;
          }
          if (BitFlags$TerrariaPacket.flag6(header3$1)) {
            tileCache.wire4 = true;
          }
          if (BitFlags$TerrariaPacket.flag7(header3$1)) {
            var $$byte$1 = ErrorAwareBufferReader$TerrariaPacket.readByte(reader, "wall_highByte");
            tileCache.wall = ($$byte$1 << 8) | tileCache.wall;
          }
          
        }
        var repeatCountBytes = ((BitFlags$TerrariaPacket.toByte(header5) & 192) >>> 6);
        rleCount = repeatCountBytes !== 0 ? (
            repeatCountBytes !== 1 ? ErrorAwareBufferReader$TerrariaPacket.readInt16(reader, "rle_int16") : ErrorAwareBufferReader$TerrariaPacket.readByte(reader, "rle_byte")
          ) : 0;
        row.push(cacheToTile(tileCache));
      }
    }
    tiles.push(row);
  }
  var chestCount = ErrorAwareBufferReader$TerrariaPacket.readInt16(reader, "chestCount");
  var chests = Belt_Array.make(chestCount, 0).map(function (param) {
        return parse(reader);
      });
  var signCount = ErrorAwareBufferReader$TerrariaPacket.readInt16(reader, "signCount");
  var signs = Belt_Array.make(signCount, 0).map(function (param) {
        return parse$1(reader);
      });
  var entityCount = ErrorAwareBufferReader$TerrariaPacket.readInt16(reader, "entityCount");
  var entities = ResultExt$TerrariaPacket.allOkOrError(Belt_Array.make(entityCount, 0).map(function (param) {
            return parse$2(reader);
          }));
  if (entities.TAG === "Ok") {
    return {
            height: height,
            width: width,
            tileX: tileX,
            tileY: tileY,
            tiles: tiles,
            chests: chests,
            signs: signs,
            entities: entities._0
          };
  }
  
}

var Decode = {
  clearTileCache: clearTileCache,
  PacketReader: undefined,
  readBuffer: ErrorAwarePacketReader$TerrariaPacket.readBuffer,
  getBytesLeft: ErrorAwarePacketReader$TerrariaPacket.getBytesLeft,
  readInt16: ErrorAwareBufferReader$TerrariaPacket.readInt16,
  readInt32: ErrorAwareBufferReader$TerrariaPacket.readInt32,
  readByte: ErrorAwareBufferReader$TerrariaPacket.readByte,
  parse: parse$3
};

function getLiquidBitFlags(tile) {
  var liquidBits = tile.honey ? "Three" : (
      tile.lava ? "Two" : (
          Belt_Option.isSome(tile.liquid) ? "One" : "Zero"
        )
    );
  switch (liquidBits) {
    case "Zero" :
        return [
                false,
                false
              ];
    case "One" :
        return [
                false,
                true
              ];
    case "Two" :
        return [
                true,
                false
              ];
    case "Three" :
        return [
                true,
                true
              ];
    
  }
}

function getSlopeBitFlags(tile) {
  if (tile.halfBrick) {
    return [
            false,
            false,
            true
          ];
  }
  var match = tile.slope;
  if (match === undefined) {
    return [
            false,
            false,
            false
          ];
  }
  switch (match) {
    case 0 :
        return [
                false,
                false,
                true
              ];
    case 1 :
        return [
                false,
                true,
                false
              ];
    case 2 :
        return [
                false,
                true,
                true
              ];
    case 3 :
        return [
                true,
                false,
                false
              ];
    case 4 :
        return [
                true,
                false,
                true
              ];
    case 5 :
        return [
                true,
                true,
                false
              ];
    default:
      return [
              true,
              true,
              true
            ];
  }
}

function getRepeatCountByteLength(repeatCount) {
  if (repeatCount > 255) {
    return 2;
  } else if (repeatCount > 0) {
    return 1;
  } else {
    return 0;
  }
}

function getRepeatCountBitFlags(repeatCount) {
  var repeatCountBytes = getRepeatCountByteLength(repeatCount);
  switch (repeatCountBytes) {
    case 0 :
        return [
                false,
                false
              ];
    case 1 :
        return [
                false,
                true
              ];
    default:
      return [
              true,
              false
            ];
  }
}

function packTile(writer, tile, repeatCount) {
  var header2 = tile.coatHeader;
  var wall = tile.wall;
  var header3 = BitFlags$TerrariaPacket.fromFlags(header2 > 0, tile.actuator, tile.inActive, Belt_Option.isSome(tile.color), Belt_Option.isSome(tile.wall) && Belt_Option.isSome(tile.wallColor), tile.wire4, wall !== undefined ? wall > 255 : false, false);
  var match = getSlopeBitFlags(tile);
  var header4 = BitFlags$TerrariaPacket.fromFlags(BitFlags$TerrariaPacket.toByte(header3) > 0, tile.wire, tile.wire2, tile.wire3, match[2], match[1], match[0], false);
  var match$1 = getLiquidBitFlags(tile);
  var match$2 = getRepeatCountBitFlags(repeatCount);
  var activeTile = tile.activeTile;
  var tileFlags = BitFlags$TerrariaPacket.fromFlags(BitFlags$TerrariaPacket.toByte(header4) > 0, Belt_Option.isSome(tile.activeTile), Belt_Option.isSome(tile.wall), match$1[1], match$1[0], activeTile !== undefined ? activeTile.tileType > 255 : false, match$2[1], match$2[0]);
  ErrorAwareBufferWriter$TerrariaPacket.packByte(writer, BitFlags$TerrariaPacket.toByte(tileFlags), "tileFlags");
  if (BitFlags$TerrariaPacket.flag1(tileFlags)) {
    ErrorAwareBufferWriter$TerrariaPacket.packByte(writer, BitFlags$TerrariaPacket.toByte(header4), "header4");
    if (BitFlags$TerrariaPacket.flag1(header4)) {
      ErrorAwareBufferWriter$TerrariaPacket.packByte(writer, BitFlags$TerrariaPacket.toByte(header3), "header3");
      if (BitFlags$TerrariaPacket.flag1(header3)) {
        ErrorAwareBufferWriter$TerrariaPacket.packByte(writer, header2, "header2");
      }
      
    }
    
  }
  var activeTile$1 = tile.activeTile;
  if (activeTile$1 !== undefined) {
    if (BitFlags$TerrariaPacket.flag6(tileFlags)) {
      ErrorAwareBufferWriter$TerrariaPacket.packByte(writer, activeTile$1.tileType & 255, "tileType_lowByte");
      ErrorAwareBufferWriter$TerrariaPacket.packByte(writer, ((activeTile$1.tileType & 65280) >>> 8), "tileType_highByte");
    } else {
      ErrorAwareBufferWriter$TerrariaPacket.packByte(writer, activeTile$1.tileType, "tileType");
    }
    var match$3 = activeTile$1.frame;
    if (match$3 !== undefined) {
      ErrorAwareBufferWriter$TerrariaPacket.packInt16(writer, match$3.x, "frameX");
      ErrorAwareBufferWriter$TerrariaPacket.packInt16(writer, match$3.y, "frameY");
    }
    var color = tile.color;
    if (color !== undefined) {
      ErrorAwareBufferWriter$TerrariaPacket.packByte(writer, color, "color");
    }
    
  }
  var wall$1 = tile.wall;
  if (wall$1 !== undefined) {
    ErrorAwareBufferWriter$TerrariaPacket.packByte(writer, wall$1 & 255, "wall_lowByte");
    var wallColor = tile.wallColor;
    if (wallColor !== undefined) {
      ErrorAwareBufferWriter$TerrariaPacket.packByte(writer, wallColor, "wallColor");
    }
    
  }
  var liquid = tile.liquid;
  if (liquid !== undefined) {
    ErrorAwareBufferWriter$TerrariaPacket.packByte(writer, liquid, "liquidValue");
  }
  var wall$2 = tile.wall;
  if (wall$2 !== undefined && wall$2 > 255) {
    ErrorAwareBufferWriter$TerrariaPacket.packByte(writer, (wall$2 >>> 8), "wall_highByte");
  }
  var match$4 = getRepeatCountByteLength(repeatCount);
  if (match$4 !== 0) {
    if (match$4 !== 1) {
      ErrorAwareBufferWriter$TerrariaPacket.packInt16(writer, repeatCount, "rle_int16");
    } else {
      ErrorAwareBufferWriter$TerrariaPacket.packByte(writer, repeatCount, "rle_byte");
    }
  }
  return writer;
}

function decidePackTile(writer, lastTile, tile) {
  var last = lastTile.contents;
  if (last !== undefined) {
    if (Caml_obj.equal(tile, last.tile)) {
      last.count = last.count + 1 | 0;
    } else {
      packTile(writer, last.tile, last.count);
      lastTile.contents = {
        tile: tile,
        count: 0
      };
    }
  } else {
    lastTile.contents = {
      tile: tile,
      count: 0
    };
  }
}

function toBuffer(self) {
  var outerPacketWriter = ErrorAwarePacketWriter$TerrariaPacket.setType(ErrorAwarePacketWriter$TerrariaPacket.make(), PacketType$TerrariaPacket.toInt("TileSectionSend"));
  var innerWriter = ErrorAwareBufferWriter$TerrariaPacket.make(Buffer.allocUnsafe(64000));
  ErrorAwareBufferWriter$TerrariaPacket.packInt16(ErrorAwareBufferWriter$TerrariaPacket.packInt16(ErrorAwareBufferWriter$TerrariaPacket.packInt32(ErrorAwareBufferWriter$TerrariaPacket.packInt32(innerWriter, self.tileX, "tileX"), self.tileY, "tileY"), self.width, "width"), self.height, "height");
  var lastTile = {
    contents: undefined
  };
  for(var y = 0 ,y_finish = self.height; y < y_finish; ++y){
    for(var x = 0 ,x_finish = self.width; x < x_finish; ++x){
      var tile = self.tiles[y][x];
      decidePackTile(innerWriter, lastTile, tile);
    }
  }
  var lastTileValue = lastTile.contents;
  if (lastTileValue !== undefined) {
    packTile(innerWriter, lastTileValue.tile, lastTileValue.count);
  }
  ErrorAwareBufferWriter$TerrariaPacket.packInt16(innerWriter, self.chests.length, "chestCount");
  self.chests.forEach(function (chest) {
        pack(innerWriter, chest);
      });
  ErrorAwareBufferWriter$TerrariaPacket.packInt16(innerWriter, self.signs.length, "signCount");
  self.signs.forEach(function (sign) {
        pack$1(innerWriter, sign);
      });
  ErrorAwareBufferWriter$TerrariaPacket.packInt16(innerWriter, self.entities.length, "entityCount");
  self.entities.forEach(function (entity) {
        pack$2(innerWriter, entity);
      });
  var innerBuffer = ErrorAwareBufferWriter$TerrariaPacket.data(innerWriter);
  if (innerBuffer.TAG === "Ok") {
    var deflatedPayload = Nodezlib.deflateRawSync(innerBuffer._0);
    return ErrorAwarePacketWriter$TerrariaPacket.data(ErrorAwarePacketWriter$TerrariaPacket.packBuffer(outerPacketWriter, deflatedPayload, "deflatedPayload"));
  }
  var e = innerBuffer._0;
  return {
          TAG: "Error",
          _0: {
            context: "innerWriter; " + e.context,
            error: e.error
          }
        };
}

var Encode = {
  setType: ErrorAwarePacketWriter$TerrariaPacket.setType,
  packBuffer: ErrorAwarePacketWriter$TerrariaPacket.packBuffer,
  packByte: ErrorAwareBufferWriter$TerrariaPacket.packByte,
  packInt16: ErrorAwareBufferWriter$TerrariaPacket.packInt16,
  packInt32: ErrorAwareBufferWriter$TerrariaPacket.packInt32,
  data: ErrorAwareBufferWriter$TerrariaPacket.data,
  getLiquidBitFlags: getLiquidBitFlags,
  getSlopeBitFlags: getSlopeBitFlags,
  getRepeatCountByteLength: getRepeatCountByteLength,
  getRepeatCountBitFlags: getRepeatCountBitFlags,
  packTile: packTile,
  decidePackTile: decidePackTile,
  toBuffer: toBuffer
};

var Int;

var $$Option;

exports.Int = Int;
exports.$$Option = $$Option;
exports.defaultTileCache = defaultTileCache;
exports.cacheToTile = cacheToTile;
exports.Chest = Chest;
exports.Sign = Sign;
exports.Entity = Entity;
exports.isTheSameAs = isTheSameAs;
exports.Decode = Decode;
exports.Encode = Encode;
exports.parse = parse$3;
exports.toBuffer = toBuffer;
/* node:zlib Not a pure module */
