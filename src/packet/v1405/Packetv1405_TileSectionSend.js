// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

let Nodezlib = require("node:zlib");
let Belt_Array = require("@rescript/runtime/lib/js/Belt_Array.js");
let Belt_Result = require("@rescript/runtime/lib/js/Belt_Result.js");
let Stdlib_Option = require("@rescript/runtime/lib/js/Stdlib_Option.js");
let Primitive_object = require("@rescript/runtime/lib/js/Primitive_object.js");
let Primitive_exceptions = require("@rescript/runtime/lib/js/Primitive_exceptions.js");
let BitFlags$TerrariaPacket = require("../../BitFlags.js");
let ResultExt$TerrariaPacket = require("../../ResultExt.js");
let TileSolid$TerrariaPacket = require("../../TileSolid.js");
let PacketType$TerrariaPacket = require("../../PacketType.js");
let ManagedPacketWriter$PacketFactory = require("@popstarfreas/packetfactory/src/ManagedPacketWriter.js");
let TileFrameImportant$TerrariaPacket = require("../../TileFrameImportant.js");
let Bufferreader = require("@popstarfreas/packetfactory/bufferreader").default;
let Bufferwriter = require("@popstarfreas/packetfactory/bufferwriter").default;
let Packetreader = require("@popstarfreas/packetfactory/packetreader").default;
let Packetwriter = require("@popstarfreas/packetfactory/packetwriter").default;

function defaultTileCache() {
  return {
    activeTile: undefined,
    color: undefined,
    wallColor: undefined,
    wall: undefined,
    liquid: undefined,
    lava: false,
    honey: false,
    wire: false,
    wire2: false,
    wire3: false,
    wire4: false,
    halfBrick: false,
    slope: undefined,
    actuator: false,
    inActive: false,
    coatHeader: 0
  };
}

function cacheToTile(cache) {
  return {
    activeTile: cache.activeTile,
    color: cache.color,
    wallColor: cache.wallColor,
    wall: cache.wall,
    liquid: cache.liquid,
    lava: cache.lava,
    honey: cache.honey,
    wire: cache.wire,
    wire2: cache.wire2,
    wire3: cache.wire3,
    wire4: cache.wire4,
    halfBrick: cache.halfBrick,
    slope: cache.slope,
    actuator: cache.actuator,
    inActive: cache.inActive,
    coatHeader: cache.coatHeader
  };
}

function readString(prim) {
  return prim.readString();
}

function readInt16(prim) {
  return prim.readInt16();
}

function readUInt16(prim) {
  return prim.readUInt16();
}

function readInt32(prim) {
  return prim.readInt32();
}

function readByte(prim) {
  return prim.readByte();
}

function parse(reader) {
  let id = reader.readInt16();
  let x = reader.readInt16();
  let y = reader.readInt16();
  let name = reader.readString();
  return {
    id: id,
    x: x,
    y: y,
    name: name
  };
}

function packByte(prim0, prim1) {
  return prim0.packByte(prim1);
}

function packInt16(prim0, prim1) {
  return prim0.packInt16(prim1);
}

function packString(prim0, prim1) {
  return prim0.packString(prim1);
}

function pack(writer, chest) {
  return writer.packInt16(chest.id).packInt16(chest.x).packInt16(chest.y).packString(chest.name);
}

let Chest = {
  readString: readString,
  readInt16: readInt16,
  readUInt16: readUInt16,
  readInt32: readInt32,
  readByte: readByte,
  parse: parse,
  packByte: packByte,
  packInt16: packInt16,
  packString: packString,
  pack: pack
};

function readString$1(prim) {
  return prim.readString();
}

function readInt16$1(prim) {
  return prim.readInt16();
}

function readUInt16$1(prim) {
  return prim.readUInt16();
}

function readInt32$1(prim) {
  return prim.readInt32();
}

function readByte$1(prim) {
  return prim.readByte();
}

function parse$1(reader) {
  let id = reader.readInt16();
  let x = reader.readInt16();
  let y = reader.readInt16();
  let name = reader.readString();
  return {
    id: id,
    x: x,
    y: y,
    name: name
  };
}

function packByte$1(prim0, prim1) {
  return prim0.packByte(prim1);
}

function packInt16$1(prim0, prim1) {
  return prim0.packInt16(prim1);
}

function packString$1(prim0, prim1) {
  return prim0.packString(prim1);
}

function pack$1(writer, sign) {
  return writer.packInt16(sign.id).packInt16(sign.x).packInt16(sign.y).packString(sign.name);
}

let Sign = {
  readString: readString$1,
  readInt16: readInt16$1,
  readUInt16: readUInt16$1,
  readInt32: readInt32$1,
  readByte: readByte$1,
  parse: parse$1,
  packByte: packByte$1,
  packInt16: packInt16$1,
  packString: packString$1,
  pack: pack$1
};

function readString$2(prim) {
  return prim.readString();
}

function readInt16$2(prim) {
  return prim.readInt16();
}

function readUInt16$2(prim) {
  return prim.readUInt16();
}

function readInt32$2(prim) {
  return prim.readInt32();
}

function readByte$2(prim) {
  return prim.readByte();
}

function parseTrainingDummyKind(reader) {
  return {
    npcSlotId: reader.readInt16()
  };
}

function parseDisplayItem(reader) {
  let netId = reader.readInt16();
  let prefix = reader.readByte();
  let stack = reader.readInt16();
  return {
    netId: netId,
    prefix: prefix,
    stack: stack
  };
}

function parseLogicSensorKind(reader) {
  let checkType = reader.readByte();
  let on = reader.readByte() === 1;
  return {
    checkType: checkType,
    on: on
  };
}

function parseDisplayDollKind(reader) {
  let itemsFlags = BitFlags$TerrariaPacket.fromByte(reader.readByte());
  let dyeFlags = BitFlags$TerrariaPacket.fromByte(reader.readByte());
  let items = [];
  let dyes = [];
  for (let i = 0; i <= 7; ++i) {
    if (BitFlags$TerrariaPacket.flagN(itemsFlags, i)) {
      items.push(parseDisplayItem(reader));
    } else {
      items.push(undefined);
    }
  }
  for (let i$1 = 0; i$1 <= 7; ++i$1) {
    if (BitFlags$TerrariaPacket.flagN(dyeFlags, i$1)) {
      dyes.push(parseDisplayItem(reader));
    } else {
      dyes.push(undefined);
    }
  }
  return {
    items: items,
    dyes: dyes
  };
}

function parseHatRackKind(reader) {
  let flags = BitFlags$TerrariaPacket.fromByte(reader.readByte());
  let items = [];
  let dyes = [];
  for (let i = 0; i <= 1; ++i) {
    if (BitFlags$TerrariaPacket.flagN(flags, i)) {
      items.push(parseDisplayItem(reader));
    } else {
      items.push(undefined);
    }
  }
  for (let i$1 = 0; i$1 <= 1; ++i$1) {
    if (BitFlags$TerrariaPacket.flagN(flags, i$1 + 2 | 0)) {
      dyes.push(parseDisplayItem(reader));
    } else {
      dyes.push(undefined);
    }
  }
  return {
    items: items,
    dyes: dyes
  };
}

function parse$2(reader) {
  let entityType = reader.readByte();
  let x = reader.readInt16();
  let y = reader.readInt16();
  let entityKind;
  switch (entityType) {
    case 0 :
      entityKind = {
        TAG: "Ok",
        _0: {
          TAG: "TrainingDummy",
          _0: {
            npcSlotId: reader.readInt16()
          }
        }
      };
      break;
    case 1 :
      entityKind = {
        TAG: "Ok",
        _0: {
          TAG: "ItemFrame",
          _0: parseDisplayItem(reader)
        }
      };
      break;
    case 2 :
      entityKind = {
        TAG: "Ok",
        _0: {
          TAG: "LogicSensor",
          _0: parseLogicSensorKind(reader)
        }
      };
      break;
    case 3 :
      entityKind = {
        TAG: "Ok",
        _0: {
          TAG: "DisplayDoll",
          _0: parseDisplayDollKind(reader)
        }
      };
      break;
    case 4 :
      entityKind = {
        TAG: "Ok",
        _0: {
          TAG: "WeaponsRack",
          _0: parseDisplayItem(reader)
        }
      };
      break;
    case 5 :
      entityKind = {
        TAG: "Ok",
        _0: {
          TAG: "HatRack",
          _0: parseHatRackKind(reader)
        }
      };
      break;
    case 6 :
      entityKind = {
        TAG: "Ok",
        _0: {
          TAG: "FoodPlatter",
          _0: parseDisplayItem(reader)
        }
      };
      break;
    case 7 :
      entityKind = {
        TAG: "Ok",
        _0: {
          TAG: "TeleportationPylon",
          _0: undefined
        }
      };
      break;
    default:
      entityKind = {
        TAG: "Error",
        _0: "File \"Packetv1405_TileSectionSend.res\", line 288, characters 17-24" + "Unknown entity kind. "
      };
  }
  return Belt_Result.map(entityKind, entityKind => ({
    entityType: entityType,
    x: x,
    y: y,
    entityKind: entityKind
  }));
}

function packByte$2(prim0, prim1) {
  return prim0.packByte(prim1);
}

function packInt16$2(prim0, prim1) {
  return prim0.packInt16(prim1);
}

function packString$2(prim0, prim1) {
  return prim0.packString(prim1);
}

function packTrainingDummy(writer, trainingDummy) {
  return writer.packInt16(trainingDummy.npcSlotId);
}

function packDisplayItem(writer, displayItem) {
  return writer.packInt16(displayItem.netId).packByte(displayItem.prefix).packInt16(displayItem.stack);
}

function packLogicSensor(writer, logicSensorKind) {
  return writer.packByte(logicSensorKind.checkType).packByte(logicSensorKind.on ? 1 : 0);
}

function hasItem(arr, n) {
  return Stdlib_Option.isSome(Stdlib_Option.flatMap(Belt_Array.get(arr, n), a => a));
}

function packDisplayDoll(writer, displayDollKind) {
  let itemFlags = BitFlags$TerrariaPacket.fromFlags(hasItem(displayDollKind.items, 0), hasItem(displayDollKind.items, 1), hasItem(displayDollKind.items, 2), hasItem(displayDollKind.items, 3), hasItem(displayDollKind.items, 4), hasItem(displayDollKind.items, 5), hasItem(displayDollKind.items, 6), hasItem(displayDollKind.items, 7));
  let dyeFlags = BitFlags$TerrariaPacket.fromFlags(hasItem(displayDollKind.dyes, 0), hasItem(displayDollKind.dyes, 1), hasItem(displayDollKind.dyes, 2), hasItem(displayDollKind.dyes, 3), hasItem(displayDollKind.dyes, 4), hasItem(displayDollKind.dyes, 5), hasItem(displayDollKind.dyes, 6), hasItem(displayDollKind.dyes, 7));
  writer.packByte(BitFlags$TerrariaPacket.toByte(itemFlags)).packByte(BitFlags$TerrariaPacket.toByte(dyeFlags));
  for (let i = 0; i <= 7; ++i) {
    let item = Stdlib_Option.flatMap(Belt_Array.get(displayDollKind.items, i), a => a);
    if (item !== undefined) {
      packDisplayItem(writer, item);
    }
  }
  for (let i$1 = 0; i$1 <= 7; ++i$1) {
    let item$1 = Stdlib_Option.flatMap(Belt_Array.get(displayDollKind.dyes, i$1), a => a);
    if (item$1 !== undefined) {
      packDisplayItem(writer, item$1);
    }
  }
  return writer;
}

function packHatRack(writer, hatRackKind) {
  let flags = BitFlags$TerrariaPacket.fromFlags(hasItem(hatRackKind.items, 0), hasItem(hatRackKind.items, 1), hasItem(hatRackKind.dyes, 2), hasItem(hatRackKind.dyes, 3), false, false, false, false);
  writer.packByte(BitFlags$TerrariaPacket.toByte(flags));
  for (let i = 0; i <= 1; ++i) {
    let item = Stdlib_Option.flatMap(Belt_Array.get(hatRackKind.items, i), a => a);
    if (item !== undefined) {
      packDisplayItem(writer, item);
    }
  }
  for (let i$1 = 0; i$1 <= 1; ++i$1) {
    let item$1 = Stdlib_Option.flatMap(Belt_Array.get(hatRackKind.dyes, i$1), a => a);
    if (item$1 !== undefined) {
      packDisplayItem(writer, item$1);
    }
  }
  return writer;
}

function packTeleportationPylon(writer, _teleportationPylonKind) {
  return writer;
}

function packEntityKind(writer, entityKind) {
  switch (entityKind.TAG) {
    case "DisplayDoll" :
      return packDisplayDoll(writer, entityKind._0);
    case "HatRack" :
      return packHatRack(writer, entityKind._0);
    case "LogicSensor" :
      return packLogicSensor(writer, entityKind._0);
    case "TeleportationPylon" :
      return writer;
    case "TrainingDummy" :
      return writer.packInt16(entityKind._0.npcSlotId);
    case "FoodPlatter" :
    case "ItemFrame" :
    case "WeaponsRack" :
      return packDisplayItem(writer, entityKind._0);
  }
}

function pack$2(writer, entity) {
  return packEntityKind(writer.packByte(entity.entityType).packInt16(entity.x).packInt16(entity.y), entity.entityKind);
}

let Entity = {
  readString: readString$2,
  readInt16: readInt16$2,
  readUInt16: readUInt16$2,
  readInt32: readInt32$2,
  readByte: readByte$2,
  parseTrainingDummyKind: parseTrainingDummyKind,
  parseDisplayItem: parseDisplayItem,
  parseItemFrameKind: parseDisplayItem,
  parseLogicSensorKind: parseLogicSensorKind,
  parseDisplayDollKind: parseDisplayDollKind,
  parseWeaponsRackKind: parseDisplayItem,
  parseHatRackKind: parseHatRackKind,
  parseFoodPlatterKind: parseDisplayItem,
  parse: parse$2,
  packByte: packByte$2,
  packInt16: packInt16$2,
  packString: packString$2,
  packTrainingDummy: packTrainingDummy,
  packDisplayItem: packDisplayItem,
  packItemFrame: packDisplayItem,
  packLogicSensor: packLogicSensor,
  hasItem: hasItem,
  packDisplayDoll: packDisplayDoll,
  packWeaponsRack: packDisplayItem,
  packHatRack: packHatRack,
  packFoodPlatter: packDisplayItem,
  packTeleportationPylon: packTeleportationPylon,
  packEntityKind: packEntityKind,
  pack: pack$2
};

let isTheSameAs = Primitive_object.equal;

function clearTileCache(tile) {
  tile.activeTile = undefined;
  tile.color = undefined;
  tile.wallColor = undefined;
  tile.wall = undefined;
  tile.liquid = undefined;
  tile.lava = false;
  tile.honey = false;
  tile.wire = false;
  tile.wire2 = false;
  tile.wire3 = false;
  tile.wire4 = false;
  tile.halfBrick = false;
  tile.slope = undefined;
  tile.actuator = false;
  tile.inActive = false;
}

function readBuffer(prim0, prim1) {
  return prim0.readBuffer(prim1);
}

function getBytesLeft(prim) {
  return prim.bytesLeft;
}

function readString$3(prim) {
  return prim.readString();
}

function readInt16$3(prim) {
  return prim.readInt16();
}

function readUInt16$3(prim) {
  return prim.readUInt16();
}

function readInt32$3(prim) {
  return prim.readInt32();
}

function readByte$3(prim) {
  return prim.readByte();
}

function parse$3(payload) {
  try {
    let reader = new Packetreader(payload);
    let compressed = reader.readByte() === 1;
    if (!compressed) {
      return {
        TAG: "Error",
        _0: {
          context: "Packetv1405_TileSectionSend.parse",
          error: new Error("Uncompressed TileSectionSend not supported")
        }
      };
    }
    let deflated = reader.readBuffer(reader.bytesLeft);
    let reader$1 = new Bufferreader(Nodezlib.inflateRawSync(deflated));
    let tileX = reader$1.readInt32();
    let tileY = reader$1.readInt32();
    let width = reader$1.readInt16();
    let height = reader$1.readInt16();
    let tiles = [];
    let tileCache = defaultTileCache();
    let rleCount = 0;
    if (height < 0 || width < 0) {
      return {
        TAG: "Error",
        _0: {
          context: "Packetv1405_TileSectionSend.parse",
          error: new Error("Invalid dimensions")
        }
      };
    }
    for (let _y = 0; _y < height; ++_y) {
      let row = [];
      for (let _x = 0; _x < width; ++_x) {
        if (rleCount !== 0) {
          rleCount = rleCount - 1 | 0;
          row.push(cacheToTile(tileCache));
        } else {
          clearTileCache(tileCache);
          let header5 = BitFlags$TerrariaPacket.fromByte(reader$1.readByte());
          let match;
          if (BitFlags$TerrariaPacket.flag1(header5)) {
            let header4 = BitFlags$TerrariaPacket.fromByte(reader$1.readByte());
            let header3 = BitFlags$TerrariaPacket.flag1(header4) ? BitFlags$TerrariaPacket.fromByte(reader$1.readByte()) : BitFlags$TerrariaPacket.fromByte(0);
            match = [
              header4,
              header3
            ];
          } else {
            match = [
              BitFlags$TerrariaPacket.fromByte(0),
              BitFlags$TerrariaPacket.fromByte(0)
            ];
          }
          let header3$1 = match[1];
          let header4$1 = match[0];
          tileCache.coatHeader = 0;
          let oldActive = tileCache.activeTile;
          if (BitFlags$TerrariaPacket.flag2(header5)) {
            let oldType = Stdlib_Option.mapOr(tileCache.activeTile, 0, active => active.tileType);
            let tileType;
            if (BitFlags$TerrariaPacket.flag6(header5)) {
              let byte = reader$1.readByte();
              let secondByte = reader$1.readByte();
              tileType = (secondByte << 8) | byte;
            } else {
              tileType = reader$1.readByte();
            }
            let frame;
            if (TileFrameImportant$TerrariaPacket.isImportant(tileType)) {
              let x = reader$1.readInt16();
              let y = reader$1.readInt16();
              frame = {
                x: x,
                y: y
              };
            } else {
              frame = Stdlib_Option.isSome(oldActive) && tileType === oldType ? oldActive.frame : undefined;
            }
            if (BitFlags$TerrariaPacket.flag4(header3$1)) {
              tileCache.color = reader$1.readByte();
            }
            tileCache.activeTile = {
              tileType: tileType,
              frame: frame
            };
          }
          if (BitFlags$TerrariaPacket.flag3(header5)) {
            tileCache.wall = reader$1.readByte();
            if (BitFlags$TerrariaPacket.flag5(header3$1)) {
              tileCache.wallColor = reader$1.readByte();
            }
          }
          let liquidBits = ((BitFlags$TerrariaPacket.toByte(header5) & 24) >> 3);
          if (liquidBits !== 0) {
            tileCache.liquid = reader$1.readByte();
            if (liquidBits > 1) {
              if (liquidBits === 2) {
                tileCache.lava = true;
              } else {
                tileCache.honey = true;
              }
            }
          }
          if (BitFlags$TerrariaPacket.toByte(header4$1) > 1) {
            if (BitFlags$TerrariaPacket.flag2(header4$1)) {
              tileCache.wire = true;
            }
            if (BitFlags$TerrariaPacket.flag3(header4$1)) {
              tileCache.wire2 = true;
            }
            if (BitFlags$TerrariaPacket.flag4(header4$1)) {
              tileCache.wire3 = true;
            }
            let slopeBits = ((BitFlags$TerrariaPacket.toByte(header4$1) & 112) >> 4);
            if (slopeBits !== 0 && TileSolid$TerrariaPacket.isSolid(Stdlib_Option.mapOr(tileCache.activeTile, 0, tile => tile.tileType))) {
              if (slopeBits === 1) {
                tileCache.halfBrick = true;
              } else {
                tileCache.slope = slopeBits - 1 | 0;
              }
            }
          }
          if (BitFlags$TerrariaPacket.toByte(header3$1) > 0) {
            if (BitFlags$TerrariaPacket.flag2(header3$1)) {
              tileCache.actuator = true;
            }
            if (BitFlags$TerrariaPacket.flag3(header3$1)) {
              tileCache.inActive = true;
            }
            if (BitFlags$TerrariaPacket.flag6(header3$1)) {
              tileCache.wire4 = true;
            }
            if (BitFlags$TerrariaPacket.flag7(header3$1)) {
              let byte$1 = reader$1.readByte();
              tileCache.wall = (byte$1 << 8) | tileCache.wall;
            }
          }
          let repeatCountBytes = ((BitFlags$TerrariaPacket.toByte(header5) & 192) >> 6);
          rleCount = repeatCountBytes !== 0 ? (
              repeatCountBytes !== 1 ? reader$1.readInt16() : reader$1.readByte()
            ) : 0;
          row.push(cacheToTile(tileCache));
        }
      }
      tiles.push(row);
    }
    let chestCount = reader$1.readInt16();
    let chests = Belt_Array.make(chestCount, 0).map(param => parse(reader$1));
    let signCount = reader$1.readInt16();
    let signs = Belt_Array.make(signCount, 0).map(param => parse$1(reader$1));
    let entityCount = reader$1.readInt16();
    let entities = ResultExt$TerrariaPacket.allOkOrError(Belt_Array.make(entityCount, 0).map(param => parse$2(reader$1)));
    if (entities.TAG === "Ok") {
      return {
        TAG: "Ok",
        _0: {
          compressed: true,
          height: height,
          width: width,
          tileX: tileX,
          tileY: tileY,
          tiles: tiles,
          chests: chests,
          signs: signs,
          entities: entities._0
        }
      };
    } else {
      return {
        TAG: "Error",
        _0: {
          context: "Packetv1405_TileSectionSend.parse.entities",
          error: new Error("Failed to parse entities")
        }
      };
    }
  } catch (raw_obj) {
    let obj = Primitive_exceptions.internalToException(raw_obj);
    if (obj.RE_EXN_ID === "JsExn") {
      return {
        TAG: "Error",
        _0: {
          context: "Packetv1405_TileSectionSend.parse",
          error: obj._1
        }
      };
    }
    throw obj;
  }
}

let Decode = {
  clearTileCache: clearTileCache,
  PacketReader: undefined,
  readBuffer: readBuffer,
  getBytesLeft: getBytesLeft,
  readString: readString$3,
  readInt16: readInt16$3,
  readUInt16: readUInt16$3,
  readInt32: readInt32$3,
  readByte: readByte$3,
  parse: parse$3
};

function getLiquidBitFlags(tile) {
  let liquidBits = tile.honey ? "Three" : (
      tile.lava ? "Two" : (
          Stdlib_Option.isSome(tile.liquid) ? "One" : "Zero"
        )
    );
  switch (liquidBits) {
    case "Zero" :
      return [
        false,
        false
      ];
    case "One" :
      return [
        false,
        true
      ];
    case "Two" :
      return [
        true,
        false
      ];
    case "Three" :
      return [
        true,
        true
      ];
  }
}

function getSlopeBitFlags(tile) {
  if (tile.halfBrick) {
    return [
      false,
      false,
      true
    ];
  }
  let match = tile.slope;
  if (match === undefined) {
    return [
      false,
      false,
      false
    ];
  }
  switch (match) {
    case 0 :
      return [
        false,
        false,
        true
      ];
    case 1 :
      return [
        false,
        true,
        false
      ];
    case 2 :
      return [
        false,
        true,
        true
      ];
    case 3 :
      return [
        true,
        false,
        false
      ];
    case 4 :
      return [
        true,
        false,
        true
      ];
    case 5 :
      return [
        true,
        true,
        false
      ];
    default:
      return [
        true,
        true,
        true
      ];
  }
}

function getRepeatCountByteLength(repeatCount) {
  if (repeatCount > 255) {
    return 2;
  } else if (repeatCount > 0) {
    return 1;
  } else {
    return 0;
  }
}

function getRepeatCountBitFlags(repeatCount) {
  let repeatCountBytes = getRepeatCountByteLength(repeatCount);
  switch (repeatCountBytes) {
    case 0 :
      return [
        false,
        false
      ];
    case 1 :
      return [
        false,
        true
      ];
    default:
      return [
        true,
        false
      ];
  }
}

function packInt16$3(prim0, prim1) {
  return prim0.packInt16(prim1);
}

function packTile(writer, tile, repeatCount) {
  let wall = tile.wall;
  let header3 = BitFlags$TerrariaPacket.fromFlags(false, tile.actuator, tile.inActive, Stdlib_Option.isSome(tile.color), Stdlib_Option.isSome(tile.wall) && Stdlib_Option.isSome(tile.wallColor), tile.wire4, wall !== undefined ? wall > 255 : false, false);
  let match = getSlopeBitFlags(tile);
  let header4 = BitFlags$TerrariaPacket.fromFlags(BitFlags$TerrariaPacket.toByte(header3) > 0, tile.wire, tile.wire2, tile.wire3, match[2], match[1], match[0], false);
  let match$1 = getLiquidBitFlags(tile);
  let match$2 = getRepeatCountBitFlags(repeatCount);
  let activeTile = tile.activeTile;
  let tileFlags = BitFlags$TerrariaPacket.fromFlags(BitFlags$TerrariaPacket.toByte(header4) > 0, Stdlib_Option.isSome(tile.activeTile), Stdlib_Option.isSome(tile.wall), match$1[1], match$1[0], activeTile !== undefined ? activeTile.tileType > 255 : false, match$2[1], match$2[0]);
  writer.packByte(BitFlags$TerrariaPacket.toByte(tileFlags));
  if (BitFlags$TerrariaPacket.flag1(tileFlags)) {
    writer.packByte(BitFlags$TerrariaPacket.toByte(header4));
    if (BitFlags$TerrariaPacket.flag1(header4)) {
      writer.packByte(BitFlags$TerrariaPacket.toByte(header3));
    }
  }
  let activeTile$1 = tile.activeTile;
  if (activeTile$1 !== undefined) {
    if (BitFlags$TerrariaPacket.flag6(tileFlags)) {
      writer.packByte(activeTile$1.tileType & 255);
      writer.packByte(((activeTile$1.tileType & 65280) >> 8));
    } else {
      writer.packByte(activeTile$1.tileType);
    }
    let match$3 = activeTile$1.frame;
    if (match$3 !== undefined) {
      writer.packInt16(match$3.x);
      writer.packInt16(match$3.y);
    }
    let color = tile.color;
    if (color !== undefined) {
      writer.packByte(color);
    }
  }
  let wall$1 = tile.wall;
  if (wall$1 !== undefined) {
    writer.packByte(wall$1 & 255);
    let wallColor = tile.wallColor;
    if (wallColor !== undefined) {
      writer.packByte(wallColor);
    }
  }
  let liquid = tile.liquid;
  if (liquid !== undefined) {
    writer.packByte(liquid);
  }
  let wall$2 = tile.wall;
  if (wall$2 !== undefined && wall$2 > 255) {
    writer.packByte((wall$2 >> 8));
  }
  let match$4 = getRepeatCountByteLength(repeatCount);
  if (match$4 !== 0) {
    if (match$4 !== 1) {
      writer.packInt16(repeatCount);
    } else {
      writer.packByte(repeatCount);
    }
  }
  return writer;
}

function decidePackTile(writer, lastTile, tile) {
  let last = lastTile.contents;
  if (last !== undefined) {
    if (Primitive_object.equal(tile, last.tile)) {
      last.count = last.count + 1 | 0;
    } else {
      packTile(writer, last.tile, last.count);
      lastTile.contents = {
        tile: tile,
        count: 0
      };
    }
  } else {
    lastTile.contents = {
      tile: tile,
      count: 0
    };
  }
}

function packByte$3(prim0, prim1) {
  return prim0.packByte(prim1);
}

function packBuffer(prim0, prim1) {
  return prim0.packBuffer(prim1);
}

function data(prim) {
  return prim.data;
}

function toBuffer(self) {
  try {
    let packetWriter = ManagedPacketWriter$PacketFactory.setType(new Packetwriter(), PacketType$TerrariaPacket.toInt("TileSectionSend"));
    let writer = new Bufferwriter(Buffer.allocUnsafe(64000));
    writer.packInt32(self.tileX).packInt32(self.tileY).packInt16(self.width).packInt16(self.height);
    let lastTile = {
      contents: undefined
    };
    for (let y = 0, y_finish = self.height; y < y_finish; ++y) {
      for (let x = 0, x_finish = self.width; x < x_finish; ++x) {
        let tile = self.tiles[y][x];
        decidePackTile(writer, lastTile, tile);
      }
    }
    let lastTile$1 = lastTile.contents;
    if (lastTile$1 !== undefined) {
      packTile(writer, lastTile$1.tile, lastTile$1.count);
    }
    writer.packInt16(self.chests.length);
    self.chests.forEach(chest => {
      pack(writer, chest);
    });
    writer.packInt16(self.signs.length);
    self.signs.forEach(sign => {
      pack$1(writer, sign);
    });
    writer.packInt16(self.entities.length);
    self.entities.forEach(entity => {
      pack$2(writer, entity);
    });
    return {
      TAG: "Ok",
      _0: packetWriter.packBuffer(Nodezlib.deflateRawSync(writer.slicedData)).data
    };
  } catch (raw_obj) {
    let obj = Primitive_exceptions.internalToException(raw_obj);
    if (obj.RE_EXN_ID === "JsExn") {
      return {
        TAG: "Error",
        _0: {
          context: "Packetv1405_TileSectionSend.toBuffer",
          error: obj._1
        }
      };
    }
    throw obj;
  }
}

let Encode = {
  getLiquidBitFlags: getLiquidBitFlags,
  getSlopeBitFlags: getSlopeBitFlags,
  getRepeatCountByteLength: getRepeatCountByteLength,
  getRepeatCountBitFlags: getRepeatCountBitFlags,
  packInt16: packInt16$3,
  packTile: packTile,
  decidePackTile: decidePackTile,
  packByte: packByte$3,
  packBuffer: packBuffer,
  setType: ManagedPacketWriter$PacketFactory.setType,
  data: data,
  BufferWriter: undefined,
  toBuffer: toBuffer
};

function toLatest(self) {
  return {
    height: self.height,
    width: self.width,
    tileX: self.tileX,
    tileY: self.tileY,
    tiles: self.tiles,
    chests: self.chests,
    signs: self.signs,
    entities: self.entities
  };
}

function fromLatest(latest) {
  return {
    compressed: false,
    height: latest.height,
    width: latest.width,
    tileX: latest.tileX,
    tileY: latest.tileY,
    tiles: latest.tiles,
    chests: latest.chests,
    signs: latest.signs,
    entities: latest.entities
  };
}

exports.defaultTileCache = defaultTileCache;
exports.cacheToTile = cacheToTile;
exports.Chest = Chest;
exports.Sign = Sign;
exports.Entity = Entity;
exports.isTheSameAs = isTheSameAs;
exports.Decode = Decode;
exports.Encode = Encode;
exports.parse = parse$3;
exports.toBuffer = toBuffer;
exports.toLatest = toLatest;
exports.fromLatest = fromLatest;
/* node:zlib Not a pure module */
