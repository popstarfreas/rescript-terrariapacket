// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

let Belt_Option = require("@rescript/runtime/lib/js/Belt_Option.js");
let BitFlags$TerrariaPacket = require("../../BitFlags.js");
let PacketType$TerrariaPacket = require("../../PacketType.js");
let ManagedPacketWriter$PacketFactory = require("@popstarfreas/packetfactory/src/ManagedPacketWriter.js");
let TileFrameImportant$TerrariaPacket = require("../../TileFrameImportant.js");
let Packetreader = require("@popstarfreas/packetfactory/packetreader").default;
let Packetwriter = require("@popstarfreas/packetfactory/packetwriter").default;

function readString(prim) {
  return prim.readString();
}

function readInt16(prim) {
  return prim.readInt16();
}

function readUInt16(prim) {
  return prim.readUInt16();
}

function readByte(prim) {
  return prim.readByte();
}

function parse(payload) {
  let reader = new Packetreader(payload);
  let packedSizeAndType = reader.readUInt16();
  let changeType = (packedSizeAndType & 32768) !== 0 ? reader.readByte() : 0;
  let width = packedSizeAndType & 32767;
  let tileX = reader.readInt16();
  let tileY = reader.readInt16();
  let tiles = [];
  for (let _x = 0; _x < width; ++_x) {
    let column = [];
    for (let _y = 0; _y < width; ++_y) {
      let flags1 = BitFlags$TerrariaPacket.fromByte(reader.readByte());
      let flags2 = BitFlags$TerrariaPacket.fromByte(reader.readByte());
      let active = BitFlags$TerrariaPacket.flag1(flags1);
      let hasWall = BitFlags$TerrariaPacket.flag3(flags1);
      let hasLiquid = BitFlags$TerrariaPacket.flag4(flags1);
      let wire = BitFlags$TerrariaPacket.flag5(flags1);
      let halfBrick = BitFlags$TerrariaPacket.flag6(flags1);
      let actuator = BitFlags$TerrariaPacket.flag7(flags1);
      let inActive = BitFlags$TerrariaPacket.flag8(flags1);
      let wire2 = BitFlags$TerrariaPacket.flag1(flags2);
      let wire3 = BitFlags$TerrariaPacket.flag2(flags2);
      let color = BitFlags$TerrariaPacket.flag3(flags2) ? reader.readByte() : undefined;
      let wallColor = BitFlags$TerrariaPacket.flag4(flags2) ? reader.readByte() : undefined;
      let activeTile;
      if (active) {
        let tileType = reader.readUInt16();
        let frame = TileFrameImportant$TerrariaPacket.isImportant(tileType) ? ({
            x: reader.readInt16(),
            y: reader.readInt16()
          }) : undefined;
        let slope = ((0 + (
          BitFlags$TerrariaPacket.flag5(flags2) ? 1 : 0
        ) | 0) + (
          BitFlags$TerrariaPacket.flag6(flags2) ? 2 : 0
        ) | 0) + (
          BitFlags$TerrariaPacket.flag7(flags2) ? 4 : 0
        ) | 0;
        activeTile = {
          tileType: tileType,
          slope: slope,
          frame: frame
        };
      } else {
        activeTile = undefined;
      }
      let wall = hasWall ? reader.readUInt16() : undefined;
      let liquid = hasLiquid ? ({
          liquidValue: reader.readByte(),
          liquidType: reader.readByte()
        }) : undefined;
      let wire4 = BitFlags$TerrariaPacket.flag8(flags2);
      column.push({
        wire: wire,
        halfBrick: halfBrick,
        actuator: actuator,
        inActive: inActive,
        wire2: wire2,
        wire3: wire3,
        wire4: wire4,
        color: color,
        wallColor: wallColor,
        activeTile: activeTile,
        wall: wall,
        liquid: liquid,
        coatHeader: 0
      });
    }
    tiles.push(column);
  }
  return {
    size: width,
    changeType: changeType,
    tileX: tileX,
    tileY: tileY,
    tiles: tiles
  };
}

let Decode = {
  readString: readString,
  readInt16: readInt16,
  readUInt16: readUInt16,
  readByte: readByte,
  parse: parse
};

function packUInt16(prim0, prim1) {
  return prim0.packUInt16(prim1);
}

function packInt16(prim0, prim1) {
  return prim0.packInt16(prim1);
}

function packByte(prim0, prim1) {
  return prim0.packByte(prim1);
}

function data(prim) {
  return prim.data;
}

function packTile(writer, tile) {
  let flags1 = BitFlags$TerrariaPacket.fromFlags(Belt_Option.isSome(tile.activeTile), false, Belt_Option.isSome(tile.wall), Belt_Option.isSome(tile.liquid), tile.wire, tile.halfBrick, tile.actuator, tile.inActive);
  let flags2 = BitFlags$TerrariaPacket.fromFlags(tile.wire2, tile.wire3, Belt_Option.isSome(tile.color), Belt_Option.isSome(tile.wallColor), Belt_Option.mapWithDefault(tile.activeTile, false, tile => (tile.slope & 1) === 1), Belt_Option.mapWithDefault(tile.activeTile, false, tile => (tile.slope & 2) === 2), Belt_Option.mapWithDefault(tile.activeTile, false, tile => (tile.slope & 4) === 4), tile.wire4);
  writer.packByte(BitFlags$TerrariaPacket.toByte(flags1)).packByte(BitFlags$TerrariaPacket.toByte(flags2));
  let color = tile.color;
  if (color !== undefined) {
    writer.packByte(color);
  }
  let color$1 = tile.wallColor;
  if (color$1 !== undefined) {
    writer.packByte(color$1);
  }
  let activeTile = tile.activeTile;
  if (activeTile !== undefined) {
    writer.packUInt16(activeTile.tileType);
    if (TileFrameImportant$TerrariaPacket.isImportant(activeTile.tileType)) {
      writer.packInt16(Belt_Option.mapWithDefault(activeTile.frame, 0, frame => frame.x)).packInt16(Belt_Option.mapWithDefault(activeTile.frame, 0, frame => frame.y));
    }
  }
  let wall = tile.wall;
  if (wall !== undefined) {
    writer.packByte(wall);
  }
  let liquid = tile.liquid;
  if (liquid !== undefined) {
    writer.packByte(liquid.liquidValue).packByte(liquid.liquidType);
  }
  return writer;
}

function packTiles(writer, tiles) {
  for (let x = 0, x_finish = tiles.length; x < x_finish; ++x) {
    for (let y = 0, y_finish = tiles[x].length; y < y_finish; ++y) {
      packTile(writer, tiles[x][y]);
    }
  }
  return writer;
}

function toBuffer(self) {
  let match = self.changeType;
  let packedSizeAndType = match !== 0 ? self.size & 32767 | 32768 : self.size & 32767;
  let writer = ManagedPacketWriter$PacketFactory.setType(new Packetwriter(), PacketType$TerrariaPacket.toInt("TileSquareSend")).packUInt16(packedSizeAndType);
  if (self.changeType !== 0) {
    writer.packByte(self.changeType);
  }
  return packTiles(writer.packInt16(self.tileX).packInt16(self.tileY), self.tiles).data;
}

let Encode = {
  packUInt16: packUInt16,
  packInt16: packInt16,
  packByte: packByte,
  setType: ManagedPacketWriter$PacketFactory.setType,
  data: data,
  packTile: packTile,
  packTiles: packTiles,
  toBuffer: toBuffer
};

function toLatest(self) {
  return {
    width: self.size,
    height: self.size,
    changeType: self.changeType,
    tileX: self.tileX,
    tileY: self.tileY,
    tiles: self.tiles
  };
}

function fromLatest(latest) {
  if (latest.width === latest.height) {
    return {
      size: latest.width,
      changeType: latest.changeType,
      tileX: latest.tileX,
      tileY: latest.tileY,
      tiles: latest.tiles
    };
  }
}

let Option;

exports.Option = Option;
exports.Decode = Decode;
exports.Encode = Encode;
exports.parse = parse;
exports.toBuffer = toBuffer;
exports.toLatest = toLatest;
exports.fromLatest = fromLatest;
/* TileFrameImportant-TerrariaPacket Not a pure module */
