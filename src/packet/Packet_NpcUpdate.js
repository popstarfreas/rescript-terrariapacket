// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

let Belt_Option = require("@rescript/runtime/lib/js/Belt_Option.js");
let BitFlags$TerrariaPacket = require("../BitFlags.js");
let PacketType$TerrariaPacket = require("../PacketType.js");
let ErrorAwarePacketReader$TerrariaPacket = require("../ErrorAwarePacketReader.js");
let ErrorAwarePacketWriter$TerrariaPacket = require("../ErrorAwarePacketWriter.js");
let Packetreader = require("@popstarfreas/packetfactory/packetreader").default;

function readNpcFlags1(reader, fieldName) {
  let flags = BitFlags$TerrariaPacket.fromByte(ErrorAwarePacketReader$TerrariaPacket.readByte(reader, fieldName));
  return {
    directionX: BitFlags$TerrariaPacket.flag1(flags),
    directionY: BitFlags$TerrariaPacket.flag2(flags),
    ai0: BitFlags$TerrariaPacket.flag3(flags),
    ai1: BitFlags$TerrariaPacket.flag4(flags),
    ai2: BitFlags$TerrariaPacket.flag5(flags),
    ai3: BitFlags$TerrariaPacket.flag6(flags),
    spriteDirection: BitFlags$TerrariaPacket.flag7(flags),
    lifeMax: BitFlags$TerrariaPacket.flag8(flags)
  };
}

function readNpcFlags2(reader, fieldName) {
  let flags = BitFlags$TerrariaPacket.fromByte(ErrorAwarePacketReader$TerrariaPacket.readByte(reader, fieldName));
  return {
    statsScaled: BitFlags$TerrariaPacket.flag1(flags),
    spawnedFromStatue: BitFlags$TerrariaPacket.flag2(flags),
    strengthMultiplier: BitFlags$TerrariaPacket.flag3(flags)
  };
}

function parse(payload) {
  let reader = new Packetreader(payload);
  let npcSlotId = ErrorAwarePacketReader$TerrariaPacket.readInt16(reader, "npcSlotId");
  let x = ErrorAwarePacketReader$TerrariaPacket.readSingle(reader, "x");
  let y = ErrorAwarePacketReader$TerrariaPacket.readSingle(reader, "y");
  let vx = ErrorAwarePacketReader$TerrariaPacket.readSingle(reader, "vx");
  let vy = ErrorAwarePacketReader$TerrariaPacket.readSingle(reader, "vy");
  let target = ErrorAwarePacketReader$TerrariaPacket.readUInt16(reader, "target");
  let npcFlags1 = readNpcFlags1(reader, "npcFlags1");
  let npcFlags2 = readNpcFlags2(reader, "npcFlags2");
  let ai_0 = npcFlags1.ai0 ? ErrorAwarePacketReader$TerrariaPacket.readSingle(reader, "ai0") : undefined;
  let ai_1 = npcFlags1.ai1 ? ErrorAwarePacketReader$TerrariaPacket.readSingle(reader, "ai1") : undefined;
  let ai_2 = npcFlags1.ai2 ? ErrorAwarePacketReader$TerrariaPacket.readSingle(reader, "ai2") : undefined;
  let ai_3 = npcFlags1.ai3 ? ErrorAwarePacketReader$TerrariaPacket.readSingle(reader, "ai3") : undefined;
  let ai = [
    ai_0,
    ai_1,
    ai_2,
    ai_3
  ];
  let npcTypeId = ErrorAwarePacketReader$TerrariaPacket.readInt16(reader, "npcTypeId");
  let playerCountScale = npcFlags2.statsScaled ? ErrorAwarePacketReader$TerrariaPacket.readByte(reader, "playerCountScale") : undefined;
  let strengthMultiplier = npcFlags2.strengthMultiplier ? ErrorAwarePacketReader$TerrariaPacket.readSingle(reader, "strengthMultiplier") : undefined;
  let life;
  if (npcFlags1.lifeMax) {
    life = "Max";
  } else {
    let lifeBytes = ErrorAwarePacketReader$TerrariaPacket.readByte(reader, "lifeBytes");
    switch (lifeBytes) {
      case 1 :
        life = {
          TAG: "Byte",
          _0: ErrorAwarePacketReader$TerrariaPacket.readSByte(reader, "life_sbyte")
        };
        break;
      case 2 :
        life = {
          TAG: "Int16",
          _0: ErrorAwarePacketReader$TerrariaPacket.readInt16(reader, "life_int16")
        };
        break;
      case 4 :
        life = {
          TAG: "Int32",
          _0: ErrorAwarePacketReader$TerrariaPacket.readInt32(reader, "life_int32")
        };
        break;
      default:
        life = undefined;
    }
  }
  let releaseOwner;
  try {
    releaseOwner = ErrorAwarePacketReader$TerrariaPacket.readByte(reader, "releaseOwner");
  } catch (exn) {
    releaseOwner = undefined;
  }
  if (life !== undefined) {
    return {
      npcSlotId: npcSlotId,
      npcTypeId: npcTypeId,
      x: x,
      y: y,
      vx: vx,
      vy: vy,
      target: target,
      directionX: npcFlags1.directionX,
      directionY: npcFlags1.directionY,
      ai: ai,
      spriteDirection: npcFlags1.spriteDirection,
      life: life,
      releaseOwner: releaseOwner,
      playerCountScale: playerCountScale,
      strengthMultiplier: strengthMultiplier,
      spawnedFromStatue: npcFlags2.spawnedFromStatue
    };
  }
}

function npcFlags1(self) {
  let match = self.ai;
  return BitFlags$TerrariaPacket.toByte(BitFlags$TerrariaPacket.fromFlags(self.directionX, self.directionY, Belt_Option.isSome(match[0]), Belt_Option.isSome(match[1]), Belt_Option.isSome(match[2]), Belt_Option.isSome(match[3]), self.spriteDirection, self.life === "Max"));
}

function npcFlags2(self) {
  return BitFlags$TerrariaPacket.toByte(BitFlags$TerrariaPacket.fromFlags(Belt_Option.isSome(self.playerCountScale), self.spawnedFromStatue, Belt_Option.isSome(self.strengthMultiplier), false, false, false, false, false));
}

function packAi(writer, param) {
  let ai3 = param[3];
  let ai2 = param[2];
  let ai1 = param[1];
  let ai0 = param[0];
  if (ai0 !== undefined) {
    ErrorAwarePacketWriter$TerrariaPacket.packSingle(writer, ai0, "ai0");
  }
  if (ai1 !== undefined) {
    ErrorAwarePacketWriter$TerrariaPacket.packSingle(writer, ai1, "ai1");
  }
  if (ai2 !== undefined) {
    ErrorAwarePacketWriter$TerrariaPacket.packSingle(writer, ai2, "ai2");
  }
  if (ai3 !== undefined) {
    ErrorAwarePacketWriter$TerrariaPacket.packSingle(writer, ai3, "ai3");
  }
  return writer;
}

function packPlayerCountScale(writer, playerCountScale) {
  if (playerCountScale !== undefined) {
    return ErrorAwarePacketWriter$TerrariaPacket.packByte(writer, playerCountScale, "playerCountScale");
  } else {
    return writer;
  }
}

function packStrengthMultiplier(writer, strengthMultiplier) {
  if (strengthMultiplier !== undefined) {
    return ErrorAwarePacketWriter$TerrariaPacket.packSingle(writer, strengthMultiplier, "strengthMultiplier");
  } else {
    return writer;
  }
}

function packLife(writer, life) {
  if (typeof life !== "object") {
    return writer;
  }
  switch (life.TAG) {
    case "Byte" :
      return ErrorAwarePacketWriter$TerrariaPacket.packSByte(ErrorAwarePacketWriter$TerrariaPacket.packByte(writer, 1, "lifeBytes"), life._0, "life_sbyte");
    case "Int16" :
      return ErrorAwarePacketWriter$TerrariaPacket.packInt16(ErrorAwarePacketWriter$TerrariaPacket.packByte(writer, 2, "lifeBytes"), life._0, "life_int16");
    case "Int32" :
      return ErrorAwarePacketWriter$TerrariaPacket.packInt32(ErrorAwarePacketWriter$TerrariaPacket.packByte(writer, 4, "lifeBytes"), life._0, "life_int32");
  }
}

function packReleaseOwner(writer, releaseOwner) {
  if (releaseOwner !== undefined) {
    return ErrorAwarePacketWriter$TerrariaPacket.packByte(writer, releaseOwner, "releaseOwner");
  } else {
    return writer;
  }
}

function toBuffer(self) {
  return ErrorAwarePacketWriter$TerrariaPacket.data(packReleaseOwner(packLife(packStrengthMultiplier(packPlayerCountScale(ErrorAwarePacketWriter$TerrariaPacket.packInt16(packAi(ErrorAwarePacketWriter$TerrariaPacket.packByte(ErrorAwarePacketWriter$TerrariaPacket.packByte(ErrorAwarePacketWriter$TerrariaPacket.packUInt16(ErrorAwarePacketWriter$TerrariaPacket.packSingle(ErrorAwarePacketWriter$TerrariaPacket.packSingle(ErrorAwarePacketWriter$TerrariaPacket.packSingle(ErrorAwarePacketWriter$TerrariaPacket.packSingle(ErrorAwarePacketWriter$TerrariaPacket.packInt16(ErrorAwarePacketWriter$TerrariaPacket.setType(ErrorAwarePacketWriter$TerrariaPacket.make(), PacketType$TerrariaPacket.toInt("NpcUpdate")), self.npcSlotId, "npcSlotId"), self.x, "x"), self.y, "y"), self.vx, "vx"), self.vy, "vy"), self.target, "target"), npcFlags1(self), "npcFlags1"), npcFlags2(self), "npcFlags2"), self.ai), self.npcTypeId, "npcTypeId"), self.playerCountScale), self.strengthMultiplier), self.life), self.releaseOwner));
}

exports.parse = parse;
exports.toBuffer = toBuffer;
/* ErrorAwarePacketWriter-TerrariaPacket Not a pure module */
