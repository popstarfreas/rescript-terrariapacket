// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

let Belt_Option = require("@rescript/runtime/lib/js/Belt_Option.js");
let BitFlags$TerrariaPacket = require("../BitFlags.js");
let PacketType$TerrariaPacket = require("../PacketType.js");
let TileFrameImportant$TerrariaPacket = require("../TileFrameImportant.js");
let ErrorAwarePacketReader$TerrariaPacket = require("../ErrorAwarePacketReader.js");
let ErrorAwarePacketWriter$TerrariaPacket = require("../ErrorAwarePacketWriter.js");
let Packetreader = require("@popstarfreas/packetfactory/packetreader").default;

function parse(payload) {
  let reader = new Packetreader(payload);
  let tileX = ErrorAwarePacketReader$TerrariaPacket.readInt16(reader, "tileX");
  let tileY = ErrorAwarePacketReader$TerrariaPacket.readInt16(reader, "tileY");
  let width = ErrorAwarePacketReader$TerrariaPacket.readByte(reader, "width");
  let height = ErrorAwarePacketReader$TerrariaPacket.readByte(reader, "height");
  let changeType = ErrorAwarePacketReader$TerrariaPacket.readByte(reader, "changeType");
  let tiles = [];
  for (let _x = 0; _x < width; ++_x) {
    let column = [];
    for (let _y = 0; _y < height; ++_y) {
      let flags1 = BitFlags$TerrariaPacket.fromByte(ErrorAwarePacketReader$TerrariaPacket.readByte(reader, "flags1"));
      let flags2 = BitFlags$TerrariaPacket.fromByte(ErrorAwarePacketReader$TerrariaPacket.readByte(reader, "flags2"));
      let flags3 = ErrorAwarePacketReader$TerrariaPacket.readByte(reader, "flags3");
      let active = BitFlags$TerrariaPacket.flag1(flags1);
      let hasWall = BitFlags$TerrariaPacket.flag3(flags1);
      let hasLiquid = BitFlags$TerrariaPacket.flag4(flags1);
      let wire = BitFlags$TerrariaPacket.flag5(flags1);
      let halfBrick = BitFlags$TerrariaPacket.flag6(flags1);
      let actuator = BitFlags$TerrariaPacket.flag7(flags1);
      let inActive = BitFlags$TerrariaPacket.flag8(flags1);
      let wire2 = BitFlags$TerrariaPacket.flag1(flags2);
      let wire3 = BitFlags$TerrariaPacket.flag2(flags2);
      let color = BitFlags$TerrariaPacket.flag3(flags2) ? ErrorAwarePacketReader$TerrariaPacket.readByte(reader, "color") : undefined;
      let wallColor = BitFlags$TerrariaPacket.flag4(flags2) ? ErrorAwarePacketReader$TerrariaPacket.readByte(reader, "wallColor") : undefined;
      let activeTile;
      if (active) {
        let tileType = ErrorAwarePacketReader$TerrariaPacket.readUInt16(reader, "tileType");
        let frame = TileFrameImportant$TerrariaPacket.isImportant(tileType) ? ({
            x: ErrorAwarePacketReader$TerrariaPacket.readInt16(reader, "frameX"),
            y: ErrorAwarePacketReader$TerrariaPacket.readInt16(reader, "frameY")
          }) : undefined;
        let slope = ((0 + (
          BitFlags$TerrariaPacket.flag5(flags2) ? 1 : 0
        ) | 0) + (
          BitFlags$TerrariaPacket.flag6(flags2) ? 2 : 0
        ) | 0) + (
          BitFlags$TerrariaPacket.flag7(flags2) ? 4 : 0
        ) | 0;
        activeTile = {
          tileType: tileType,
          slope: slope,
          frame: frame
        };
      } else {
        activeTile = undefined;
      }
      let wall = hasWall ? ErrorAwarePacketReader$TerrariaPacket.readUInt16(reader, "wall") : undefined;
      let liquid = hasLiquid ? ({
          liquidValue: ErrorAwarePacketReader$TerrariaPacket.readByte(reader, "liquidValue"),
          liquidType: ErrorAwarePacketReader$TerrariaPacket.readByte(reader, "liquidType")
        }) : undefined;
      let wire4 = BitFlags$TerrariaPacket.flag8(flags2);
      column.push({
        wire: wire,
        halfBrick: halfBrick,
        actuator: actuator,
        inActive: inActive,
        wire2: wire2,
        wire3: wire3,
        wire4: wire4,
        color: color,
        wallColor: wallColor,
        activeTile: activeTile,
        wall: wall,
        liquid: liquid,
        coatHeader: flags3
      });
    }
    tiles.push(column);
  }
  return {
    width: width,
    height: height,
    changeType: changeType,
    tileX: tileX,
    tileY: tileY,
    tiles: tiles
  };
}

function packTile(writer, tile) {
  let flags1 = BitFlags$TerrariaPacket.fromFlags(Belt_Option.isSome(tile.activeTile), false, Belt_Option.isSome(tile.wall), Belt_Option.isSome(tile.liquid), tile.wire, tile.halfBrick, tile.actuator, tile.inActive);
  let flags2 = BitFlags$TerrariaPacket.fromFlags(tile.wire2, tile.wire3, Belt_Option.isSome(tile.color), Belt_Option.isSome(tile.wallColor), Belt_Option.mapWithDefault(tile.activeTile, false, tile => (tile.slope & 1) === 1), Belt_Option.mapWithDefault(tile.activeTile, false, tile => (tile.slope & 2) === 2), Belt_Option.mapWithDefault(tile.activeTile, false, tile => (tile.slope & 4) === 4), tile.wire4);
  ErrorAwarePacketWriter$TerrariaPacket.packByte(ErrorAwarePacketWriter$TerrariaPacket.packByte(ErrorAwarePacketWriter$TerrariaPacket.packByte(writer, BitFlags$TerrariaPacket.toByte(flags1), "flags1"), BitFlags$TerrariaPacket.toByte(flags2), "flags2"), tile.coatHeader, "coatHeader");
  let c = tile.color;
  if (c !== undefined) {
    ErrorAwarePacketWriter$TerrariaPacket.packByte(writer, c, "color");
  }
  let wc = tile.wallColor;
  if (wc !== undefined) {
    ErrorAwarePacketWriter$TerrariaPacket.packByte(writer, wc, "wallColor");
  }
  let at = tile.activeTile;
  if (at !== undefined) {
    ErrorAwarePacketWriter$TerrariaPacket.packUInt16(writer, at.tileType, "tileType");
    if (TileFrameImportant$TerrariaPacket.isImportant(at.tileType)) {
      ErrorAwarePacketWriter$TerrariaPacket.packInt16(ErrorAwarePacketWriter$TerrariaPacket.packInt16(writer, Belt_Option.mapWithDefault(at.frame, 0, frame => frame.x), "frameX"), Belt_Option.mapWithDefault(at.frame, 0, frame => frame.y), "frameY");
    }
  }
  let w = tile.wall;
  if (w !== undefined) {
    ErrorAwarePacketWriter$TerrariaPacket.packUInt16(writer, w, "wall");
  }
  let l = tile.liquid;
  if (l !== undefined) {
    ErrorAwarePacketWriter$TerrariaPacket.packByte(ErrorAwarePacketWriter$TerrariaPacket.packByte(writer, l.liquidValue, "liquidValue"), l.liquidType, "liquidType");
  }
  return writer;
}

function packTiles(writer, tiles) {
  for (let x = 0, x_finish = tiles.length; x < x_finish; ++x) {
    for (let y = 0, y_finish = tiles[x].length; y < y_finish; ++y) {
      packTile(writer, tiles[x][y]);
    }
  }
  return writer;
}

function toBuffer(self) {
  return ErrorAwarePacketWriter$TerrariaPacket.data(packTiles(ErrorAwarePacketWriter$TerrariaPacket.packByte(ErrorAwarePacketWriter$TerrariaPacket.packByte(ErrorAwarePacketWriter$TerrariaPacket.packByte(ErrorAwarePacketWriter$TerrariaPacket.packInt16(ErrorAwarePacketWriter$TerrariaPacket.packInt16(ErrorAwarePacketWriter$TerrariaPacket.setType(ErrorAwarePacketWriter$TerrariaPacket.make(), PacketType$TerrariaPacket.toInt("TileSquareSend")), self.tileX, "tileX"), self.tileY, "tileY"), self.width, "width"), self.height, "height"), self.changeType, "changeType"), self.tiles));
}

let Decode = {
  parse: parse
};

let Encode = {
  toBuffer: toBuffer
};

exports.Decode = Decode;
exports.Encode = Encode;
exports.parse = parse;
exports.toBuffer = toBuffer;
/* TileFrameImportant-TerrariaPacket Not a pure module */
