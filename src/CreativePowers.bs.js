// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Core__Array = require("@rescript/core/src/Core__Array.bs.js");
var Core__Option = require("@rescript/core/src/Core__Option.bs.js");

function pack(writer, self) {
  return writer.packByte(self.playerId).packSingle(self.value);
}

function parse(reader) {
  return {
          playerId: reader.readByte(),
          value: reader.readSingle()
        };
}

function pack$1(writer, self) {
  if (self.TAG === "Everyone") {
    var values = self._0;
    var bytes = (((values) => {
        let buffer = new Uint8Array(32);
        for (let i = 0; i < 30; i++) {
          let chunkIndex = i * 8;
          buffer[i] = (
              (values[chunkIndex + 0] ? 1 << 0 : 0)
            | (values[chunkIndex + 1] ? 1 << 1 : 0)
            | (values[chunkIndex + 2] ? 1 << 2 : 0)
            | (values[chunkIndex + 3] ? 1 << 3 : 0)
            | (values[chunkIndex + 4] ? 1 << 4 : 0)
            | (values[chunkIndex + 5] ? 1 << 5 : 0)
            | (values[chunkIndex + 6] ? 1 << 6 : 0)
            | (values[chunkIndex + 7] ? 1 << 7 : 0)
          );
        }
        buffer[31] = (
            (values[248] ? 1 << 0 : 0)
          | (values[249] ? 1 << 1 : 0)
          | (values[250] ? 1 << 2 : 0)
          | (values[251] ? 1 << 3 : 0)
          | (values[252] ? 1 << 4 : 0)
          | (values[253] ? 1 << 5 : 0)
          | (values[254] ? 1 << 6 : 0)
        );
        return Array.from(buffer);
      }))(values);
    bytes.forEach(function ($$byte) {
          writer.packByte($$byte);
        });
    return writer;
  } else {
    var playerId = self._0;
    var value = self._1;
    return writer.packByte(playerId).packByte(value ? 1 : 0);
  }
}

function parse$1(reader) {
  var match = reader.readByte();
  if (match !== 0) {
    if (match !== 1) {
      return ;
    } else {
      return {
              TAG: "Player",
              _0: reader.readByte(),
              _1: reader.readByte() === 1
            };
    }
  } else {
    var bytes = Core__Array.fromInitializer(32, (function (param) {
            return reader.readByte();
          }));
    var toggles = ((() => {
        let buffer = Array(256).fill(false);
        for (let i = 0; i < bytes.length; i++) {
          let byte = bytes[i];
          buffer[i * 8 + 0] = (byte & (1 << 0)) !== 0;
          buffer[i * 8 + 1] = (byte & (1 << 1)) !== 0;
          buffer[i * 8 + 2] = (byte & (1 << 2)) !== 0;
          buffer[i * 8 + 3] = (byte & (1 << 3)) !== 0;
          buffer[i * 8 + 4] = (byte & (1 << 4)) !== 0;
          buffer[i * 8 + 5] = (byte & (1 << 5)) !== 0;
          buffer[i * 8 + 6] = (byte & (1 << 6)) !== 0;
          buffer[i * 8 + 7] = (byte & (1 << 7)) !== 0;
        }
        // logic is easier if the array had one extra bool
        buffer.length = 255;
        return buffer;
      }))(bytes);
    return {
            TAG: "Everyone",
            _0: toggles
          };
  }
}

function fromInt(n) {
  switch (n) {
    case 0 :
        return "FreezeTime";
    case 1 :
        return "StartDayImmediately";
    case 2 :
        return "StartNoonImmediately";
    case 3 :
        return "StartNightImmediately";
    case 4 :
        return "StartMidnightImmediately";
    case 5 :
        return "GodmodePower";
    case 6 :
        return "ModifyWindDirectionAndStrength";
    case 7 :
        return "ModifyRainPower";
    case 8 :
        return "ModifyTimeRate";
    case 9 :
        return "FreezeRainPower";
    case 10 :
        return "FreezeWindDirectionAndStrength";
    case 11 :
        return "FarPlacementRangePower";
    case 12 :
        return "DifficultySliderPower";
    case 13 :
        return "StopBiomeSpreadPower";
    case 14 :
        return "SpawnRateSliderPerPlayerPower";
    default:
      return ;
  }
}

function toInt(self) {
  switch (self) {
    case "FreezeTime" :
        return 0;
    case "StartDayImmediately" :
        return 1;
    case "StartNoonImmediately" :
        return 2;
    case "StartNightImmediately" :
        return 3;
    case "StartMidnightImmediately" :
        return 4;
    case "GodmodePower" :
        return 5;
    case "ModifyWindDirectionAndStrength" :
        return 6;
    case "ModifyRainPower" :
        return 7;
    case "ModifyTimeRate" :
        return 8;
    case "FreezeRainPower" :
        return 9;
    case "FreezeWindDirectionAndStrength" :
        return 10;
    case "FarPlacementRangePower" :
        return 11;
    case "DifficultySliderPower" :
        return 12;
    case "StopBiomeSpreadPower" :
        return 13;
    case "SpawnRateSliderPerPlayerPower" :
        return 14;
    
  }
}

var CreativePowerType = {
  fromInt: fromInt,
  toInt: toInt
};

function pack$2(writer, self) {
  if (typeof self !== "object") {
    switch (self) {
      case "StartDayImmediately" :
          return writer.packUInt16(1);
      case "StartNoonImmediately" :
          return writer.packUInt16(2);
      case "StartNightImmediately" :
          return writer.packUInt16(3);
      case "StartMidnightImmediately" :
          return writer.packUInt16(4);
      
    }
  } else {
    switch (self.TAG) {
      case "FreezeTime" :
          var value = self._0;
          return writer.packUInt16(0).packByte(value ? 1 : 0);
      case "GodmodePower" :
          var message = self._0;
          return pack$1(writer.packUInt16(5), message);
      case "ModifyWindDirectionAndStrength" :
          var value$1 = self._0;
          return writer.packUInt16(6).packSingle(value$1);
      case "ModifyRainPower" :
          var value$2 = self._0;
          return writer.packUInt16(7).packSingle(value$2);
      case "ModifyTimeRate" :
          var value$3 = self._0;
          return writer.packUInt16(8).packSingle(value$3);
      case "FreezeRainPower" :
          var on = self._0;
          return writer.packUInt16(9).packByte(on ? 1 : 0);
      case "FreezeWindDirectionAndStrength" :
          var on$1 = self._0;
          return writer.packUInt16(10).packByte(on$1 ? 1 : 0);
      case "FarPlacementRangePower" :
          var message$1 = self._0;
          return pack$1(writer.packUInt16(11), message$1);
      case "DifficultySliderPower" :
          var value$4 = self._0;
          return writer.packUInt16(12).packSingle(value$4);
      case "StopBiomeSpreadPower" :
          var on$2 = self._0;
          return writer.packUInt16(13).packByte(on$2 ? 1 : 0);
      case "SpawnRateSliderPerPlayerPower" :
          var message$2 = self._0;
          return pack(writer.packUInt16(14), message$2);
      
    }
  }
}

function parse$2(reader) {
  var match = reader.readUInt16();
  switch (match) {
    case 0 :
        return {
                TAG: "FreezeTime",
                _0: reader.readByte() === 1
              };
    case 1 :
        return "StartDayImmediately";
    case 2 :
        return "StartNoonImmediately";
    case 3 :
        return "StartNightImmediately";
    case 4 :
        return "StartMidnightImmediately";
    case 5 :
        return Core__Option.map(parse$1(reader), (function (m) {
                      return {
                              TAG: "GodmodePower",
                              _0: m
                            };
                    }));
    case 6 :
        return {
                TAG: "ModifyWindDirectionAndStrength",
                _0: reader.readSingle()
              };
    case 7 :
        return {
                TAG: "ModifyRainPower",
                _0: reader.readSingle()
              };
    case 8 :
        return {
                TAG: "ModifyTimeRate",
                _0: reader.readSingle()
              };
    case 9 :
        return {
                TAG: "FreezeRainPower",
                _0: reader.readByte() === 1
              };
    case 10 :
        return {
                TAG: "FreezeWindDirectionAndStrength",
                _0: reader.readByte() === 1
              };
    case 11 :
        return Core__Option.map(parse$1(reader), (function (m) {
                      return {
                              TAG: "FarPlacementRangePower",
                              _0: m
                            };
                    }));
    case 12 :
        return {
                TAG: "DifficultySliderPower",
                _0: reader.readSingle()
              };
    case 13 :
        return {
                TAG: "StopBiomeSpreadPower",
                _0: reader.readByte() === 1
              };
    case 14 :
        return Core__Option.map(parse(reader), (function (m) {
                      return {
                              TAG: "SpawnRateSliderPerPlayerPower",
                              _0: m
                            };
                    }));
    default:
      return ;
  }
}

var PerPlayerSliderPower = {
  pack: pack,
  parse: parse
};

var PerPlayerTogglePower = {
  pack: pack$1,
  parse: parse$1
};

exports.PerPlayerSliderPower = PerPlayerSliderPower;
exports.PerPlayerTogglePower = PerPlayerTogglePower;
exports.CreativePowerType = CreativePowerType;
exports.pack = pack$2;
exports.parse = parse$2;
/* No side effect */
